# inventory_management.py

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QLabel,
    QLineEdit, QHBoxLayout, QPushButton, QGridLayout, QMessageBox, QComboBox,
    QHeaderView, QFormLayout, QSpacerItem, QSizePolicy
)
from PyQt6.QtCore import Qt
from data import inventory, load_inventory_from_db, data_manager, save_inventory_to_db
import datetime
import re
from dateutil.parser import parse

class InventoryManagementWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("库存管理")
        self.setGeometry(300, 300, 1000, 600)

        self.layout_main = QVBoxLayout()

        # 输入区域
        self.layout_inputs = QFormLayout()
        self.entries = {}

        # 调整间距
        self.layout_inputs.setSpacing(5)
        self.layout_inputs.setContentsMargins(0, 0, 0, 0)

        # 修改后的“到货日期”输入项
        label_arrival_date = QLabel("到货日期:")
        self.entry_arrival_date = QLineEdit()
        self.entry_arrival_date.setPlaceholderText("YYYY-MM-DD")
        self.entries['Arrival_Date'] = self.entry_arrival_date
        self.layout_inputs.addRow(label_arrival_date, self.entry_arrival_date)
        self.entry_arrival_date.setFixedWidth(120)

        # 新增的“提货日期”输入项
        label_pickup_date = QLabel("提货日期:")
        self.entry_pickup_date = QLineEdit()
        self.entry_pickup_date.setPlaceholderText("YYYY-MM-DD")
        self.entries['Pick_up_Date'] = self.entry_pickup_date
        self.layout_inputs.addRow(label_pickup_date, self.entry_pickup_date)
        self.entry_pickup_date.setFixedWidth(120)

        # 更新按钮
        self.button_update = QPushButton("更新")
        self.button_update.clicked.connect(self.update_inventory_record)
        # 将“更新”按钮添加到新的行
        button_layout = QHBoxLayout()
        button_layout.addStretch(1)
        button_layout.addWidget(self.button_update)
        button_layout.addStretch(1)
        self.layout_inputs.addRow(button_layout)

        self.layout_main.addLayout(self.layout_inputs)

        # 明细标题和过滤选项
        detail_layout = QHBoxLayout()

        # 添加排序和过滤控件的布局
        control_layout = QHBoxLayout()

        # 添加排序选项
        sort_label = QLabel("排序规则:")
        self.sort_combo = QComboBox()
        self.sort_combo.addItems(["按更新时间", "按采购订单号", "按销售订单", "按产品编号", "按库存-箱数"])
        self.sort_combo.currentIndexChanged.connect(self.update_inventory_tables)
        sort_layout = QHBoxLayout()
        sort_layout.addWidget(sort_label)
        sort_layout.addWidget(self.sort_combo)
        sort_layout.setSpacing(5)
        sort_layout.setContentsMargins(0, 0, 0, 0)
        control_layout.addLayout(sort_layout)

        # 添加过滤选项
        filter_field_label = QLabel("过滤条件:")
        self.filter_field_combo = QComboBox()
        self.filter_field_combo.addItems(["按产品编号", "按采购订单", "按Order Type", "按SKU CLS", "按产品名称"])
        self.filter_field_combo.currentIndexChanged.connect(self.update_inventory_tables)
        self.filter_field_input = QLineEdit()
        self.filter_field_input.setPlaceholderText("输入过滤内容")
        self.filter_field_input.textChanged.connect(self.update_inventory_tables)
        self.filter_field_input.setFixedWidth(150)
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(filter_field_label)
        filter_layout.addWidget(self.filter_field_combo)
        filter_layout.addWidget(self.filter_field_input)
        filter_layout.setSpacing(5)
        filter_layout.setContentsMargins(0, 0, 0, 0)
        control_layout.addLayout(filter_layout)

        # 添加弹性空间，将控件靠左对齐
        control_layout.addStretch(1)

        # 添加“库存明细”标签并使其居中
        title_layout = QHBoxLayout()
        title_layout.addStretch(1)
        detail_label = QLabel("库存明细")
        detail_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_layout.addWidget(detail_label)
        title_layout.addStretch(1)

        # 将控件布局和标题布局添加到 detail_layout
        detail_layout.addLayout(control_layout)
        detail_layout.addLayout(title_layout)

        self.layout_main.addLayout(detail_layout)

        # 明细库存列表
        self.detail_inventory_table = QTableWidget()
        self.detail_inventory_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.detail_inventory_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.detail_inventory_table.setColumnCount(13)
        self.detail_inventory_table.setHorizontalHeaderLabels([
            'Order Type', '采购订单', '销售订单', '产品编号', 'SKU CLS', '产品名称',
            '库存-箱数', '总瓶数', '库存天数', '到货日期', '提货日期', '售空日期', '创建日期'
        ])
        self.detail_inventory_table.verticalHeader().setVisible(False)
        # 修改列宽调整模式
        header = self.detail_inventory_table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        # 平均分配列宽
        for i in range(self.detail_inventory_table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.Stretch)

        self.layout_main.addWidget(self.detail_inventory_table)

        # 总览标题
        total_label = QLabel("库存总览")
        total_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout_main.addWidget(total_label)

        # 总览库存列表
        self.total_inventory_table = QTableWidget()
        self.total_inventory_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.total_inventory_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.total_inventory_table.setColumnCount(7)
        self.total_inventory_table.setHorizontalHeaderLabels(['产品编号', '采购订单', '销售订单', 'SKU CLS', '产品名称', '库存-箱数','库存-总瓶数'])
        self.total_inventory_table.verticalHeader().setVisible(False)
        # 修改列宽调整模式
        total_header = self.total_inventory_table.horizontalHeader()
        total_header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        # 平均分配列宽
        for i in range(self.total_inventory_table.columnCount()):
            total_header.setSectionResizeMode(i, QHeaderView.ResizeMode.Stretch)

        self.layout_main.addWidget(self.total_inventory_table)

        self.setLayout(self.layout_main)

        # 初始化变量
        self.selected_inventory_item = None

        # 连接选择信号到处理函数
        self.detail_inventory_table.selectionModel().selectionChanged.connect(self.on_order_selected)
        # 连接数据变化信号到更新方法
        data_manager.inventory_changed.connect(self.on_inventory_changed)
        # 加载库存数据
        load_inventory_from_db()
        self.update_inventory_tables()

    def on_inventory_changed(self):
        self.update_inventory_tables()

    def on_order_selected(self, selected, deselected):
        indexes = self.detail_inventory_table.selectionModel().selectedRows()
        if indexes:
            index = indexes[0]
            row = index.row()
            # 获取选中的库存记录
            product_id = self.detail_inventory_table.item(row, 3).text()
            order_nb = self.detail_inventory_table.item(row, 1).text()
            # 查找对应的库存项
            inventory_item = next((item for item in inventory if item['Product_ID'] == product_id and item['Order_Nb'] == order_nb), None)
            if inventory_item:
                self.selected_inventory_item = inventory_item
                # 填充输入框
                self.entry_arrival_date.setText(inventory_item.get('Arrival_Date', ''))
                self.entry_pickup_date.setText(inventory_item.get('Pick_up_Date', ''))
            else:
                self.selected_inventory_item = None
                self.entry_arrival_date.clear()
                self.entry_pickup_date.clear()
        else:
            self.selected_inventory_item = None
            self.entry_arrival_date.clear()
            self.entry_pickup_date.clear()

    def update_inventory_record(self):
        if not self.selected_inventory_item:
            QMessageBox.warning(self, "更新错误", "请先选择要更新的库存记录！")
            return
        # 获取输入的日期
        arrival_date_str = self.entry_arrival_date.text().strip()
        pickup_date_str = self.entry_pickup_date.text().strip()
        # 创建一个标志，检查是否有更新
        has_update = False
        # 验证并更新到货日期
        if arrival_date_str:
            try:
                arrival_date = datetime.datetime.strptime(arrival_date_str, '%Y-%m-%d')
                self.selected_inventory_item['Arrival_Date'] = arrival_date_str
                has_update = True
            except ValueError:
                QMessageBox.warning(self, "输入错误", "到货日期格式错误，请输入正确的日期格式：YYYY-MM-DD")
                return
        # 验证并更新提货日期
        if pickup_date_str:
            try:
                pickup_date = datetime.datetime.strptime(pickup_date_str, '%Y-%m-%d')
                self.selected_inventory_item['Pick_up_Date'] = pickup_date_str
                has_update = True
            except ValueError:
                QMessageBox.warning(self, "输入错误", "提货日期格式错误，请输入正确的日期格式：YYYY-MM-DD")
                return
        if has_update:
            # 在保存之前，创建一个副本并移除不属于数据库的字段
            inventory_item_to_save = self.selected_inventory_item.copy()
            inventory_item_to_save.pop('Order_Type', None)  # 移除 Order_Type 字段
            # 保存到数据库
            save_inventory_to_db(inventory_item_to_save)
            QMessageBox.information(self, "成功", "库存记录已更新。")
            # 更新表格
            self.update_inventory_tables()
        else:
            QMessageBox.warning(self, "更新错误", "没有可更新的日期，请输入至少一个日期。")

    def update_inventory_tables(self):
        # 获取当前选择的排序规则
        sort_option = self.sort_combo.currentText()

        # 获取额外的过滤条件
        filter_field = self.filter_field_combo.currentText()
        filter_value = self.filter_field_input.text().strip()

        # 复制库存数据以进行过滤和排序
        filtered_inventory = inventory.copy()

        # 处理过滤条件
        if filter_value:
            if filter_field == "按产品编号":
                filtered_inventory = [item for item in filtered_inventory if filter_value.lower() in item.get('Product_ID', '').lower()]
            elif filter_field == "按采购订单":
                filtered_inventory = [item for item in filtered_inventory if filter_value.lower() in item.get('Order_Nb', '').lower()]
            elif filter_field == "按Order Type":
                filtered_inventory = [item for item in filtered_inventory if filter_value.lower() in item.get('Order_Type', '').lower()]
            elif filter_field == "按SKU CLS":
                filtered_inventory = [item for item in filtered_inventory if filter_value.lower() in item.get('SKU_CLS', '').lower()]
            elif filter_field == "按产品名称":
                # 将用户输入的通配符模式转换为正则表达式
                pattern = re.escape(filter_value).replace(r'\*', '.*')
                regex = re.compile(pattern, re.IGNORECASE)
                filtered_inventory = [item for item in filtered_inventory if regex.search(item.get('Product_Name', ''))]

        # 根据排序规则对数据排序
        if sort_option == "按更新时间":
            sorted_inventory = sorted(filtered_inventory, key=lambda x: x.get('Last_Update', ''), reverse=True)
        elif sort_option == "按采购订单号":
            sorted_inventory = sorted(filtered_inventory, key=lambda x: x.get('Order_Nb', ''))
        elif sort_option == "按销售订单":
            sorted_inventory = sorted(filtered_inventory, key=lambda x: x.get('Sales_Orders', ''))
        elif sort_option == "按产品编号":
            sorted_inventory = sorted(filtered_inventory, key=lambda x: x.get('Product_ID', ''))
        elif sort_option == "按库存-箱数":
            sorted_inventory = sorted(filtered_inventory, key=lambda x: int(x.get('Current_Stock_CS', 0)), reverse=True)
        else:
            sorted_inventory = filtered_inventory

        # 建立订单号到销售订单的映射
        order_nb_to_sales_orders = {}
        for item in sorted_inventory:
            order_nb = item['Order_Nb']
            sales_order = item.get('Sales_Orders', '')
            if order_nb not in order_nb_to_sales_orders:
                order_nb_to_sales_orders[order_nb] = set()
            if sales_order:
                order_nb_to_sales_orders[order_nb].update(
                    [s.strip() for s in sales_order.split(',')]
                )

        # 更新明细表
        self.detail_inventory_table.setRowCount(0)
        self.detail_inventory_table.setRowCount(len(sorted_inventory))
        for row, product in enumerate(sorted_inventory):
            self.detail_inventory_table.setItem(row, 0, QTableWidgetItem(product.get('Order_Type', '')))
            self.detail_inventory_table.setItem(row, 1, QTableWidgetItem(product['Order_Nb']))
            self.detail_inventory_table.setItem(row, 3, QTableWidgetItem(product['Product_ID']))
            self.detail_inventory_table.setItem(row, 4, QTableWidgetItem(product.get('SKU_CLS', '')))
            self.detail_inventory_table.setItem(row, 5, QTableWidgetItem(product['Product_Name']))
            self.detail_inventory_table.setItem(row, 6, QTableWidgetItem(str(product['Current_Stock_CS'])))
            # 计算总瓶数
            btl_per_cs = int(product.get('BTL PER CS', 0))
            total_btl = int(product['Current_Stock_CS']) * btl_per_cs
            self.detail_inventory_table.setItem(row, 7, QTableWidgetItem(str(total_btl)))
            # 计算库存天数
            arrival_date_str = product.get('Arrival_Date', '')
            pickup_date_str = product.get('Pick_up_Date', '')
            if arrival_date_str:
                arrival_date = parse(arrival_date_str)
                if pickup_date_str:
                    pickup_date = parse(pickup_date_str)
                    delta_days = (pickup_date - arrival_date).days
                else:
                    delta_days = (datetime.datetime.now() - arrival_date).days

                self.detail_inventory_table.setItem(row, 8, QTableWidgetItem(str(delta_days)))
            else:
                self.detail_inventory_table.setItem(row, 8, QTableWidgetItem("N/A"))

            self.detail_inventory_table.setItem(row, 9, QTableWidgetItem(product.get('Arrival_Date', '')))
            self.detail_inventory_table.setItem(row, 12, QTableWidgetItem(product.get('Creation_Date', '')))
            self.detail_inventory_table.setItem(row, 10, QTableWidgetItem(product.get('Pick_up_Date', '')))
            self.detail_inventory_table.setItem(row, 11, QTableWidgetItem(product.get('Sale_Date', '')))

            # 获取对应订单号的销售订单
            sales_orders = order_nb_to_sales_orders.get(product['Order_Nb'], set())
            sales_order_str = ', '.join(sorted(sales_orders))
            self.detail_inventory_table.setItem(row, 2, QTableWidgetItem(sales_order_str))

        # 更新总览表，应用相同的排序和过滤规则
        total_inventory = {}
        for product in sorted_inventory:
            product_id = product['Product_ID']
            order_nb = product.get('Order_Nb', '')
            sales_order = product.get('Sales_Orders', '')
            sku_cls = product.get('SKU_CLS', '')
            product_name = product['Product_Name']
            current_stock_cs = int(product['Current_Stock_CS'])
            btl_per_cs = int(product.get('BTL PER CS', 0))
            current_stock_btl = current_stock_cs * btl_per_cs
            if product_id not in total_inventory:
                total_inventory[product_id] = {
                    'Product_ID': product_id,
                    'Order_Nb_Set': set([order_nb]),
                    'Sales_Order_Set': set(),
                    'SKU_CLS': sku_cls,
                    'Product_Name': product_name,
                    'Current_Stock_CS': current_stock_cs,
                    'Current_Stock_BTL': current_stock_btl
                }
            else:
                total_inventory[product_id]['Order_Nb_Set'].add(order_nb)
                total_inventory[product_id]['Current_Stock_CS'] += current_stock_cs
                total_inventory[product_id]['Current_Stock_BTL'] += current_stock_btl

            # 收集销售订单
            if sales_order:
                total_inventory[product_id]['Sales_Order_Set'].update(
                    [s.strip() for s in sales_order.split(',')]
                )

        # 将聚合后的数据转换为列表
        total_inventory_list = list(total_inventory.values())

        # 根据排序规则对总览表数据排序
        if sort_option == "按更新时间":
            # 总览表没有直接的更新时间字段，这里暂时不排序
            pass
        elif sort_option == "按采购订单号":
            total_inventory_list = sorted(total_inventory_list, key=lambda x: ','.join(sorted(x['Order_Nb_Set'])))
        elif sort_option == "按销售订单":
            total_inventory_list = sorted(total_inventory_list, key=lambda x: ','.join(sorted(x['Sales_Order_Set'])))
        elif sort_option == "按产品编号":
            total_inventory_list = sorted(total_inventory_list, key=lambda x: x.get('Product_ID', ''))
        elif sort_option == "按库存-箱数":
            total_inventory_list = sorted(total_inventory_list, key=lambda x: x.get('Current_Stock_CS', 0), reverse=True)

        # 更新总览表
        self.total_inventory_table.setRowCount(0)
        self.total_inventory_table.setRowCount(len(total_inventory_list))
        for row, product in enumerate(total_inventory_list):
            self.total_inventory_table.setItem(row, 0, QTableWidgetItem(product['Product_ID']))
            order_nb_str = ', '.join(sorted(product['Order_Nb_Set']))
            self.total_inventory_table.setItem(row, 1, QTableWidgetItem(order_nb_str))
            self.total_inventory_table.setItem(row, 3, QTableWidgetItem(product.get('SKU_CLS', '')))
            self.total_inventory_table.setItem(row, 4, QTableWidgetItem(product['Product_Name']))
            self.total_inventory_table.setItem(row, 5, QTableWidgetItem(str(product['Current_Stock_CS'])))
            self.total_inventory_table.setItem(row, 6, QTableWidgetItem(str(product['Current_Stock_BTL'])))

            # 展示销售订单
            sales_order_str = ', '.join(sorted(product['Sales_Order_Set']))
            self.total_inventory_table.setItem(row, 2, QTableWidgetItem(sales_order_str))
# data.py
import sqlite3
import datetime
import json
from PyQt6.QtWidgets import QMessageBox
from PyQt6.QtCore import QObject, pyqtSignal

# 定义共享数据
purchase_orders = []
sales_orders = []
inventory = []
deleted_orders = []
products = []
db_fields = [
    ("订单号", "Order Nb"),
    ("Product_ID", "Product_ID"),
    ("Order Type", "Order Type"),
    ("Order Step", "Order Step"),
    ("期望利润", "Expected Profit"),
    ("境内运费(CAD)", "Domestic Freight CAD"),
    ("EXW汇率", "EXW Exchange Rate"),
    ("国际运费(€)", "International Freight EURO"),
    ("国际运费汇率", "International Freight Exchange Rate"),
    ("TOTAL Freight", "TOTAL Freight"),
    ("Supplier", "Supplier"),
    ("BCMB", "BCMB"),
    ("SKU CLS", "SKU CLS"),
    ("供应商发票号", "Supplier Order Number"),
    ("ITEM Name", "ITEM Name"),
    ("CATEGORY", "CATEGORY"),
    ("SIZE", "SIZE"),
    ("ALC.", "ALC."),
    ("QUANTITY CS", "QUANTITY CS"),
    ("BTL PER CS", "BTL PER CS"),
    ("QUANTITY BTL", "QUANTITY BTL"),
    ("EXW(€)", "EXW EURO"),
    ("TOTAL AMOUNT(€)", "TOTAL AMOUNT EURO"),
    ("REMARKS", "REMARKS"),
    ("WHOLESALE BTL", "WHOLESALE BTL"),
    ("WHOLESALE CS", "WHOLESALE CS"),
    ("PROFIT PER BT", "PROFIT PER BT"),
    ("PROFIT PER CS", "PROFIT PER CS"),
    ("PROFIT TOTAL", "PROFIT TOTAL"),
    ("INVOICE PRICE", "INVOICE PRICE"),
    ("INVOICE CS", "INVOICE CS"),
    ("Date", "date"),
    ("UCC14", "UCC14"),
    ("UCC13", "UCC13"),
]

# 数据管理器，用于发射数据变化信号
class DataManager(QObject):
    data_changed = pyqtSignal()
    inventory_changed = pyqtSignal()
    products_changed = pyqtSignal()
    def __init__(self):
        super().__init__()

data_manager = DataManager()

# 初始化数据库
def initialize_database():
    conn = sqlite3.connect('orders.db')
    cursor = conn.cursor()

    # 创建采购订单表
    field_definitions = ', '.join([f'"{field[1]}" TEXT' for field in db_fields if field[1] != 'Order Nb'])
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS purchase_orders (
            "Order Nb" TEXT PRIMARY KEY,
            {field_definitions}
        )
    ''')

    # 创建销售订单表
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS sales_orders (
            "Sales_ID" TEXT PRIMARY KEY,
            "Product_ID" TEXT,
            "Customer_ID" TEXT,
            "Quantity_CS_Sold" INTEGER,
            "Quantity_BTL_Sold" INTEGER,
            "Total_Quantity_BTL_Sold" INTEGER,
            "Price_per_bottle" REAL,
            "Total_Amount" REAL,
            "Order_Date" TEXT,
            "Shipped_Date" TEXT,
            "Remarks" TEXT,
            "Deduction_Details" TEXT,
            "Order_Nb" TEXT,
            "Product_Name",
            "BTL_PER_CS" INTEGER
        )
    ''')

    # 创建库存表
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS inventory (
            "Product_ID" TEXT,
            "Order_Nb" TEXT,
            "Product_Name" TEXT,
            "SKU_CLS" TEXT,
            "Current_Stock_CS" INTEGER,
            "BTL PER CS" INTEGER,
            "Last_Update" TEXT,
            "Arrival_Date" TEXT,
            "Creation_Date" TEXT,
            "Sale_Date" TEXT,
            "Sales_Orders" TEXT,
            "Pick_up_Date" TEXT,
            PRIMARY KEY ("Product_ID", "Order_Nb")
        )
    ''')
    #创建产品表
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS products (
            "SKU_CLS" TEXT PRIMARY KEY,
            "ITEM_Name" TEXT,
            "Category" TEXT,
            "Size" REAL,
            "ALC" REAL,
            "BTL_PER_CS" INTEGER,
            "Supplier" TEXT,
            "Creation_Date" TEXT
        )
    ''')
    conn.commit()
    conn.close()

# 加载采购订单
def load_purchase_orders_from_db():
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM purchase_orders')
        rows = cursor.fetchall()
        conn.close()

        purchase_orders.clear()
        reversed_rows = rows[::-1]
        for row in reversed_rows:
            order = {}
            for idx, field in enumerate(cursor.description):
                field_name = field[0]
                order[field_name] = row[idx] if row[idx] is not None else ''
            purchase_orders.append(order)
    except Exception as e:
        print(f"无法从数据库加载采购订单数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载采购订单数据：{e}")

# 保存采购订单
def save_purchase_order_to_db(order):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        placeholders = ', '.join(['?' for _ in order.keys()])
        field_names = ', '.join([f'"{key}"' for key in order.keys()])
        values = list(order.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO purchase_orders ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存采购订单时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存采购订单时发生错误：{e}")

# 删除采购订单
def delete_purchase_order_from_db(order_nb):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        cursor.execute('DELETE FROM purchase_orders WHERE "Order Nb" = ?', (order_nb,))
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"删除采购订单时发生错误：{e}")
        QMessageBox.critical(None, "删除错误", f"删除采购订单时发生错误：{e}")

# 加载销售订单
def load_sales_orders_from_db():
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM sales_orders')
        rows = cursor.fetchall()
        conn.close()

        sales_orders.clear()
        reversed_rows = rows[::-1]
        for row in reversed_rows:
            order = {}
            for idx, field in enumerate(cursor.description):
                field_name = field[0]
                if field_name == 'Deduction_Details':
                    order[field_name] = json.loads(row[idx]) if row[idx] else []
                else:
                    order[field_name] = row[idx] if row[idx] is not None else ''
            sales_orders.append(order)
    except Exception as e:
        print(f"无法从数据库加载销售订单数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载销售订单数据：{e}")

# 保存销售订单
def save_sales_order_to_db(order):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()

        # 序列化 Deduction_Details
        deduction_details_json = json.dumps(order.get('Deduction_Details', []))
        # 创建一个副本用于保存，不修改原始 order 对象
        order_to_save = order.copy()
        order_to_save['Deduction_Details'] = deduction_details_json

        placeholders = ', '.join(['?' for _ in order_to_save.keys()])
        field_names = ', '.join([f'"{key}"' for key in order_to_save.keys()])
        values = list(order_to_save.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO sales_orders ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存销售订单时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存销售订单时发生错误：{e}")


# 删除销售订单
def delete_sales_order_from_db(sales_id):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        cursor.execute('DELETE FROM sales_orders WHERE "Sales_ID" = ?', (sales_id,))
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"删除销售订单时发生错误：{e}")
        QMessageBox.critical(None, "删除错误", f"删除销售订单时发生错误：{e}")

# 加载库存数据
def load_inventory_from_db():
    try:
        global inventory
        conn = sqlite3.connect('orders.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM inventory')
        rows = cursor.fetchall()
        conn.close()

        inventory.clear()
        for row in rows:
            product = dict(row)
            # 从采购订单中获取对应的 Order Type
            order_nb = product.get('Order_Nb', '')
            purchase_order = get_purchase_order_by_nb(order_nb)
            product['Order_Type'] = purchase_order.get('Order Type', '') if purchase_order else ''
            inventory.append(product)
    except Exception as e:
        print(f"无法从数据库加载库存数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载库存数据：{e}")

# 保存库存数据
def save_inventory_to_db(product):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        placeholders = ', '.join(['?' for _ in product.keys()])
        field_names = ', '.join([f'"{key}"' for key in product.keys()])
        values = list(product.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO inventory ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存库存数据时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存库存数据时发生错误：{e}")

# 更新库存数量
def update_inventory(product_id, order_nb, quantity_change_cs, arrival_date, creation_date, item_name, sku_cls, btl_per_cs, operation_type, sale_date=None, sales_orders=None, operation_subtype=None, Pick_up_Date=None ):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        
        # 查询当前库存
        cursor.execute('SELECT "Current_Stock_CS", "BTL PER CS", "Sales_Orders" FROM inventory WHERE "Product_ID" = ? AND "Order_Nb" = ?', (product_id, order_nb))
        result = cursor.fetchone()
        if result:
            # 如果库存记录存在，更新库存数量
            current_stock_cs = int(result[0])
            #current_btl_per_cs = int(result[1])
            new_stock_cs = current_stock_cs + quantity_change_cs

            if new_stock_cs < 0: #or new_stock_btl < 0:
                raise ValueError("库存不足，无法减少库存")
            
            # 获取当前 Sales_Orders
            existing_sales_orders = set(result[2].split(',')) if result[2] else set()
            if operation_subtype == 'remove_sales_order':
                # 移除指定值
                remove_sales_orders = set(sales_orders.split(',')) if sales_orders else set()
                updated_sales_orders = existing_sales_orders - remove_sales_orders
                updated_sales_orders_str = ','.join(sorted(updated_sales_orders))
            else:
                new_sales_orders = set(sales_orders.split(',')) if sales_orders else set()
                updated_sales_orders_str = ','.join(sorted(existing_sales_orders.union(new_sales_orders)))
            print(f"operation_subtype: {operation_subtype}")
            # 更新库存
            if new_stock_cs == 0: #and new_stock_btl == 0:
                if operation_type == 'revoke_purchase_order':
                    # 撤销采购订单导致库存为零，删除库存记录
                    cursor.execute('DELETE FROM inventory WHERE "Product_ID" = ? AND "Order_Nb" = ?', (product_id, order_nb))
                else:
                    # 正常销售导致库存为零，保留库存记录
                    cursor.execute('UPDATE inventory SET "Product_ID" = ?, "Order_Nb" = ?, "Product_Name" = ?, "SKU_CLS" = ?, "Current_Stock_CS" = 0, "BTL PER CS" = ?, "Last_Update" = ?, "Arrival_Date" = ?, "Creation_Date" = ?, "Sale_Date" = ?, "Sales_Orders" = ? WHERE "Product_ID" = ? AND "Order_Nb" = ?',
                                   (product_id, order_nb, item_name, sku_cls, btl_per_cs, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), arrival_date, creation_date, sale_date or datetime.datetime.now().strftime("%Y-%m-%d"), updated_sales_orders_str, product_id, order_nb))
            else:
                # 库存数量不为零，更新库存记录
                cursor.execute('UPDATE inventory SET "Product_ID" = ?, "Order_Nb" = ?, "Product_Name" = ?, "SKU_CLS" = ?, "Current_Stock_CS" = ?, "BTL PER CS" = ?, "Last_Update" = ?, "Arrival_Date" = ?, "Creation_Date" = ?, "Sale_Date" = NULL, "Sales_Orders" = ? WHERE "Product_ID" = ? AND "Order_Nb" = ?',
                               (product_id, order_nb, item_name, sku_cls, new_stock_cs, btl_per_cs, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), arrival_date, creation_date, updated_sales_orders_str, product_id, order_nb))

        else:
            # 库存记录不存在
            if quantity_change_cs > 0:#or quantity_change_btl > 0:
                # 增加库存，新增库存记录
                cursor.execute('INSERT INTO inventory ("Product_ID", "Order_Nb", "Product_Name", "SKU_CLS", "Current_Stock_CS", "BTL PER CS", "Last_Update", "Arrival_Date", "Creation_Date") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
                               (product_id, order_nb, item_name, sku_cls, quantity_change_cs, btl_per_cs, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), arrival_date, creation_date))
            else:
                # 减少库存，且库存记录不存在，抛出异常
                raise ValueError("库存中不存在该产品，无法减少库存")

        conn.commit()
        conn.close()

        # 更新内存中的 inventory 列表
        load_inventory_from_db()
        # 发射 inventory_changed 信号
        data_manager.inventory_changed.emit()

    except Exception as e:
        print(f"更新库存时发生错误：{e}")
        raise e

# 获取库存记录
def get_inventory_item(product_id, order_nb):
    for item in inventory:
        if item['Product_ID'] == product_id and item['Order_Nb'] == order_nb:
            return item
    return None
#获取产品信息
def get_inventory_info(product_id, order_nb):
    for item in inventory:
        if item['Product_ID'] == product_id and item['Order_Nb'] == order_nb:
            return item.get('Product_Name', ''), int(item.get('BTL PER CS', 0))
    return '', 0

# 更新库存中的 Arrival_Date
def update_inventory_arrival_date(product_id, order_nb, arrival_date):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        cursor.execute('UPDATE inventory SET "Arrival_Date" = ? WHERE "Product_ID" = ? AND "Order_Nb" = ?', (arrival_date, product_id, order_nb))
        conn.commit()
        conn.close()

        # 更新内存中的 inventory 列表
        load_inventory_from_db()
        data_manager.inventory_changed.emit()
    except Exception as e:
        print(f"更新库存 Arrival_Date 时发生错误：{e}")
        raise e

# 恢复库存（用于删除销售订单）
def restore_inventory(sales_order):
    try:
        # 从销售订单中获取扣减详情
        deduction_details = sales_order.get('Deduction_Details', [])
        if not deduction_details:
            raise ValueError("销售订单中缺少扣减详情，无法恢复库存")

        for deduction in deduction_details:
            # 确保 deduction 是一个字典
            if not isinstance(deduction, dict):
                raise ValueError(f"扣减详情格式错误：{deduction}")

            product_id = sales_order['Product_ID']
            order_nb = deduction['Order_Nb']
            add_cs = deduction['Deduct_CS']

            # 获取库存记录的信息
            inventory_item = get_inventory_item(product_id, order_nb)
            if not inventory_item:
                raise ValueError(f"无法找到库存记录，产品ID: {product_id}, 订单号: {order_nb}")

            btl_per_cs = int(inventory_item.get('BTL PER CS', 0))
            current_stock_cs = int(inventory_item.get('Current_Stock_CS', 0))
            arrival_date = inventory_item.get('Arrival_Date')
            creation_date = inventory_item.get('Creation_Date')
            product_name = inventory_item.get('Product_Name')
            sku_cls = inventory_item.get('SKU_CLS')
            # 计算新的瓶数和箱数
            new_stock_cs = current_stock_cs + add_cs
            '''# 获取现有的 Sales_Orders
            existing_sales_orders = inventory_item.get('Sales_Orders', '')
            if existing_sales_orders:
                # 将字符串转换为集合
                existing_sales_orders_set = set(existing_sales_orders.split(','))
                # 从集合中移除当前销售订单号
                updated_sales_orders_set = existing_sales_orders_set - {sales_order['Sales_ID']}
                # 转换回字符串
                updated_sales_orders = ','.join(sorted(updated_sales_orders_set))
            else:
                updated_sales_orders = None'''
            # 更新库存
            update_inventory(
                product_id,
                order_nb,
                new_stock_cs - current_stock_cs,
                arrival_date,
                creation_date,
                product_name,
                sku_cls,
                btl_per_cs,
                operation_type='restore_sales',
                sales_orders = sales_order['Sales_ID'],
                operation_subtype = 'remove_sales_order'
            )

    except Exception as e:
        print(f"恢复库存时发生错误：{e}")
        raise e


# 根据订单号获取采购订单
def get_purchase_order_by_nb(order_nb):
    return next((order for order in purchase_orders if order['Order Nb'] == order_nb), None)

# 根据 Product_ID 获取采购订单
def get_purchase_order_by_product_id(product_id):
    for order in purchase_orders:
        if order['Product_ID'] == product_id:
            return order
    return None

# 获取 BTL_PER_CS
def get_btl_per_cs(product_id):
    order = get_purchase_order_by_product_id(product_id)
    if order:
        return int(order.get('BTL PER CS', 0))
    else:
        return 0

# 获取 WHOLESALE BTL
def get_WHOLESALE_BTL_price(product_id):
    order = get_purchase_order_by_product_id(product_id)
    if order:
        wholesale_btl = order.get('WHOLESALE BTL', 0)
        # 检查 wholesale_btl 是否为字符串，如果不是，转换为字符串
        if not isinstance(wholesale_btl, str):
            wholesale_btl = str(wholesale_btl)
        # 检查是否为空字符串或无法转换成浮点数
        if wholesale_btl.strip() == '':
            wholesale_btl = '0'  # 如果为空字符串，将其设置为 '0'
        try:
            return float(wholesale_btl)
        except ValueError:
            # 处理转换错误，返回默认值或抛出更具体的错误
            print(f"Invalid value for WHOLESALE BTL: {wholesale_btl}")
            return 0.0  # 返回默认值
        #print(f"获取到的WHOLESALE BTL 为：{wholesale_btl}")
    else:
        return 0.0

# 加载产品数据
def load_products_from_db():
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM products')
        rows = cursor.fetchall()
        conn.close()

        products.clear()
        for row in rows:
            product = {}
            for idx, field in enumerate(cursor.description):
                field_name = field[0]
                product[field_name] = row[idx] if row[idx] is not None else ''
            products.append(product)
    except Exception as e:
        print(f"无法从数据库加载产品数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载产品数据：{e}")

# 保存产品
def save_product_to_db(product):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        placeholders = ', '.join(['?' for _ in product.keys()])
        field_names = ', '.join([f'"{key}"' for key in product.keys()])
        values = list(product.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO products ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存产品时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存产品时发生错误：{e}")

# 删除产品
def delete_product_from_db(sku_cls):
    try:
        conn = sqlite3.connect('orders.db')
        cursor = conn.cursor()
        cursor.execute('DELETE FROM products WHERE "SKU_CLS" = ?', (sku_cls,))
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"删除产品时发生错误：{e}")
        QMessageBox.critical(None, "删除错误", f"删除产品时发生错误：{e}")

# 根据 SKU_CLS 获取产品
def get_product_by_sku(sku_cls):
    return next((product for product in products if product['SKU_CLS'] == sku_cls), None)

# 在采购订单添加时检查并添加新产品
def check_and_add_new_product(order):
    sku_cls = str(order.get('SKU CLS', '')).strip()
    product = get_product_by_sku(sku_cls)
    if not product:
        # 产品不存在，自动添加到产品列表
        new_product = {
            'SKU_CLS': sku_cls,
            'ITEM_Name': order.get('ITEM Name', ''),
            'Category': order.get('CATEGORY', ''),
            'Size': float(order.get('SIZE', 0)),
            'ALC': float(order.get('ALC.', 0)),
            'BTL_PER_CS': int(order.get('BTL PER CS', 0)),
            'Supplier': order.get('Supplier', ''),
            'Creation_Date': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        products.append(new_product)
        save_product_to_db(new_product)
        data_manager.products_changed.emit()
        QMessageBox.information(None, "新产品添加", f"产品 {sku_cls} 为新产品，已自动添加到产品列表中。")
    else:
        # 产品已存在，验证信息一致性
        inconsistencies = []
        fields_to_check = ['ITEM_Name', 'Category', 'Size', 'ALC', 'BTL_PER_CS', 'Supplier']
        for field in fields_to_check:
            order_field = order.get(field.replace('_', ' '), '')
            product_field = product.get(field, '')
            if str(order_field).strip() != str(product_field).strip():
                print(f"order_field{order_field}")
                print(f"order_field{product_field}")
                inconsistencies.append(field)
        if inconsistencies:
            QMessageBox.warning(None, "产品信息不一致", f"产品 {sku_cls} 的以下信息与产品列表不一致：{', '.join(inconsistencies)}。请检查。")
            # product_management.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QGridLayout, QComboBox
)
from PyQt6.QtCore import Qt

from data import (
    products, save_product_to_db, delete_product_from_db,
    load_products_from_db, data_manager, get_product_by_sku
)
import datetime
import re

class ProductManagementWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("产品管理")
        self.setGeometry(200, 200, 800, 600)

        self.layout_main = QVBoxLayout()

        # 输入区域
        self.layout_inputs = QGridLayout()
        self.entries = {}

        fields = [
            ('SKU CLS', 'SKU_CLS'),
            ('ITEM Name', 'ITEM_Name'),
            ('Category', 'Category'),
            ('Size', 'Size'),
            ('ALC.', 'ALC'),
            ('BTL PER CS', 'BTL_PER_CS'),
            ('Supplier', 'Supplier'),
        ]

        for row, (label_text, field_name) in enumerate(fields):
            label = QLabel(label_text + ":")
            label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            entry = QLineEdit()
            entry.setFixedWidth(300)
            entry.setStyleSheet("border: 1px solid lightgray;")
            self.entries[field_name] = entry
            self.layout_inputs.addWidget(label, row, 0)
            self.layout_inputs.addWidget(entry, row, 1)

        self.layout_main.addLayout(self.layout_inputs)

        # 按钮区域
        layout_buttons = QHBoxLayout()

        self.button_add = QPushButton("添加产品")
        self.button_add.clicked.connect(self.add_product)
        self.button_update = QPushButton("更新产品")
        self.button_update.clicked.connect(self.update_product)
        self.button_delete = QPushButton("删除产品")
        self.button_delete.clicked.connect(self.delete_product)

        layout_buttons.addWidget(self.button_add)
        layout_buttons.addWidget(self.button_update)
        layout_buttons.addWidget(self.button_delete)

        self.layout_main.addLayout(layout_buttons)

        # 产品列表显示区域
        self.product_table = QTableWidget()
        self.product_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.product_table.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)
        self.product_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.product_table.setColumnCount(8)
        self.product_table.setHorizontalHeaderLabels([
            'SKU CLS', 'ITEM Name', 'Category', 'Size', 'ALC.', 'BTL PER CS', 'Supplier', '创建日期'
        ])
        self.product_table.verticalHeader().setVisible(False)
        self.product_table.horizontalHeader().setStretchLastSection(True)
        self.product_table.setWordWrap(True)
        self.product_table.resizeColumnsToContents()

        # 连接产品表格的选择信号到处理函数
        self.product_table.selectionModel().selectionChanged.connect(self.on_product_selected)

        self.layout_main.addWidget(self.product_table)

        self.setLayout(self.layout_main)

        # 加载产品数据
        load_products_from_db()
        self.update_product_table()

        # 连接数据变化信号到更新方法
        data_manager.products_changed.connect(self.update_product_table)

    def on_product_selected(self, selected, deselected):
        try:
            indexes = self.product_table.selectionModel().selectedRows()
            if indexes:
                index = indexes[0]
                row = index.row()
                product = products[row]
                for field_name, entry in self.entries.items():
                    value = product.get(field_name, "")
                    entry.setText(str(value))
            else:
                for entry in self.entries.values():
                    entry.clear()
        except Exception as e:
            print(f"处理产品选择时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"处理产品选择时发生错误：{e}")

    def add_product(self):
        try:
            new_product = {}
            for field_name, entry in self.entries.items():
                value = entry.text().strip()
                if not value:
                    QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                    return
                new_product[field_name] = value

            # 检查 SKU_CLS 是否已存在
            sku_cls = new_product['SKU_CLS']
            if any(product['SKU_CLS'] == sku_cls for product in products):
                QMessageBox.warning(self, "添加失败", f"产品 {sku_cls} 已存在！")
                return

            # 转换数据类型
            try:
                new_product['Size'] = float(new_product['Size'])
                new_product['ALC'] = float(new_product['ALC'])
                new_product['BTL_PER_CS'] = int(new_product['BTL_PER_CS'])
            except ValueError:
                QMessageBox.warning(self, "输入错误", "Size、ALC.、BTL PER CS 必须是有效的数字！")
                return

            new_product['Creation_Date'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            products.append(new_product)
            save_product_to_db(new_product)
            data_manager.products_changed.emit()

            self.update_product_table()
            QMessageBox.information(self, "成功", f"产品 {sku_cls} 已添加。")
        except Exception as e:
            print(f"添加产品时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"添加产品时发生错误：{e}")

    def update_product(self):
        try:
            sku_cls = self.entries['SKU_CLS'].text().strip()
            if not sku_cls:
                QMessageBox.warning(self, "更新失败", "请输入 SKU CLS！")
                return

            # 获取现有产品数据
            existing_product = get_product_by_sku(sku_cls)
            if not existing_product:
                QMessageBox.warning(self, "更新失败", f"产品 {sku_cls} 不存在！")
                return

            # 准备更新后的产品数据
            updated_product = {}
            for field_name, entry in self.entries.items():
                value = entry.text().strip()
                if not value:
                    QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                    return
                updated_product[field_name] = value

            # 转换数据类型
            try:
                updated_product['Size'] = float(updated_product['Size'])
                updated_product['ALC'] = float(updated_product['ALC'])
                updated_product['BTL_PER_CS'] = int(updated_product['BTL_PER_CS'])
            except ValueError:
                QMessageBox.warning(self, "输入错误", "Size、ALC.、BTL PER CS 必须是有效的数字！")
                return

            # 保留创建日期
            updated_product['Creation_Date'] = existing_product['Creation_Date']

            # 更新产品列表和数据库
            index = products.index(existing_product)
            products[index] = updated_product
            save_product_to_db(updated_product)
            data_manager.products_changed.emit()

            self.update_product_table()
            QMessageBox.information(self, "成功", f"产品 {sku_cls} 已更新。")
        except Exception as e:
            print(f"更新产品时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"更新产品时发生错误：{e}")

    def delete_product(self):
        try:
            sku_cls = self.entries['SKU_CLS'].text().strip()
            if not sku_cls:
                QMessageBox.warning(self, "删除失败", "请输入 SKU CLS！")
                return

            product = get_product_by_sku(sku_cls)
            if product:
                # 从产品列表中删除
                products.remove(product)
                # 从数据库中删除
                delete_product_from_db(sku_cls)
                data_manager.products_changed.emit()

                self.update_product_table()
                QMessageBox.information(self, "成功", f"产品 {sku_cls} 已删除。")
            else:
                QMessageBox.information(self, "删除失败", f"未找到 SKU CLS 为 {sku_cls} 的产品。")
        except Exception as e:
            print(f"删除产品时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"删除产品时发生错误：{e}")

    def update_product_table(self):
        # 更新产品表格显示
        self.product_table.setRowCount(0)
        self.product_table.setRowCount(len(products))
        for row, product in enumerate(products):
            self.product_table.setItem(row, 0, QTableWidgetItem(product.get('SKU_CLS', '')))
            self.product_table.setItem(row, 1, QTableWidgetItem(product.get('ITEM_Name', '')))
            self.product_table.setItem(row, 2, QTableWidgetItem(product.get('Category', '')))
            self.product_table.setItem(row, 3, QTableWidgetItem(str(product.get('Size', ''))))
            self.product_table.setItem(row, 4, QTableWidgetItem(str(product.get('ALC', ''))))
            self.product_table.setItem(row, 5, QTableWidgetItem(str(product.get('BTL_PER_CS', ''))))
            self.product_table.setItem(row, 6, QTableWidgetItem(product.get('Supplier', '')))
            self.product_table.setItem(row, 7, QTableWidgetItem(product.get('Creation_Date', '')))
# order_details.py
import datetime
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QGridLayout, QComboBox, QFileDialog
)
from PyQt6.QtCore import Qt
import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import PatternFill

from data import (
    purchase_orders, deleted_orders, db_fields, delete_purchase_order_from_db,
    save_purchase_order_to_db, data_manager, update_inventory, inventory,
    update_inventory_arrival_date, get_purchase_order_by_nb, products, get_product_by_sku, save_product_to_db,
    load_products_from_db
)
from price_calculator import open_price_calculator
import json
import re

class OrderDetailsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("采购订单管理")
        self.setGeometry(200, 200, 1400, 700)

        self.layout_main = QVBoxLayout()

        # 输入区域
        self.layout_inputs = QGridLayout()
        self.layout_inputs.setHorizontalSpacing(10)
        self.entries = {}

        # 左侧字段
        left_fields = [
            ('订单号', 'Order Nb'),
            ('产品编号', 'Product_ID'),
            ('Order Type', 'Order Type'),
            ('Order Step', 'Order Step'),
            ('期望利润', "Expected Profit"),
            ('境内运费', 'Domestic Freight CAD'),
            ('国际运费', 'International Freight EURO'),
            ('EXW 汇率', 'EXW Exchange Rate'),
            ('国际运费汇率', 'International Freight Exchange Rate'),
            # 新增字段
            ("UCC14", "UCC14"),
            ("UCC13", "UCC13"),
        ]

        # 右侧字段
        right_fields = [
            ("Supplier", "Supplier"),
            ("BCMB", "BCMB"),
            ("SKU CLS", "SKU CLS"),
            ("Supplier Order Number", "Supplier Order Number"),
            ("ITEM Name", "ITEM Name"),
            ("CATEGORY", "CATEGORY"),
            ("SIZE", "SIZE"),
            ("ALC.", "ALC."),
            ("QUANTITY CS", "QUANTITY CS"),
            ("BTL PER CS", "BTL PER CS"),
            ("EXW(€)", "EXW EURO"),
            ("REMARKS", "REMARKS"),
        ]

        # 左侧字段
        for row, (label_text, field_name) in enumerate(left_fields):
            label = QLabel(label_text + ":")
            label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            if field_name == "Order Type":
                entry = QComboBox()
                entry.addItems(["Allocation", "In Stock"])
                entry.setCurrentText("Allocation")
            elif field_name == "Order Step":
                entry = QComboBox()
                entry.addItems(["Offer", "Order", "Delivery"])
                entry.setCurrentText("Offer")
            elif field_name == "Expected Profit":
                entry = QLineEdit()
                entry.setText("0.05")
            elif field_name == "Domestic Freight CAD":
                entry = QLineEdit()
                entry.setText("35")
            elif field_name == "International Freight EURO":
                entry = QLineEdit()
                entry.setText("0")
            elif field_name == "EXW Exchange Rate":
                entry = QLineEdit()
                entry.setText("0")
            elif field_name == "International Freight Exchange Rate":
                entry = QLineEdit()
                entry.setText("0")
            elif field_name == "Arrival_Date":
                entry = QLineEdit()
                entry.setPlaceholderText("YYYY-MM-DD")
            else:
                entry = QLineEdit()
            entry.setFixedWidth(500)
            entry.setStyleSheet("border: 1px solid lightgray;")
            self.entries[field_name] = entry
            self.layout_inputs.addWidget(label, row, 0)
            self.layout_inputs.addWidget(entry, row, 1)

        # 右侧字段
        for row, (label_text, field_name) in enumerate(right_fields):
            label = QLabel(label_text + ":")
            label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            if field_name == "Supplier": 
                entry = QComboBox() 
                entry.addItems(["Filips", "CVBG", "DULONG", "BONCHATEAU"]) 
            elif field_name == "CATEGORY": 
                entry = QComboBox() 
                entry.addItems(["RED", "WHITE"]) 
                entry.setCurrentText("RED")
            elif field_name == "SIZE":
                entry = QComboBox()
                entry.addItems(["0.75", "1.5", "3", "6", "9"])
                entry.setCurrentText("0.75")
            else:
                entry = QLineEdit()
            entry.setFixedWidth(500)
            entry.setStyleSheet("border: 1px solid lightgray;")
            self.entries[field_name] = entry
            self.layout_inputs.addWidget(label, row, 2)
            self.layout_inputs.addWidget(entry, row, 3)

        self.layout_main.addLayout(self.layout_inputs)
        # 按钮区域
        layout_buttons = QHBoxLayout()

        self.button_add = QPushButton("添加采购订单")
        self.button_add.clicked.connect(self.add_order)

        self.button_update = QPushButton("更新采购订单")
        self.button_update.clicked.connect(self.update_order)

        self.entry_search = QLineEdit()
        self.entry_search.setMaxLength(15)
        self.entry_search.setFixedWidth(100)
        button_search = QPushButton("查找订单")
        button_search.clicked.connect(self.find_order)

        self.entry_delete = QLineEdit()
        self.entry_delete.setMaxLength(15)
        self.entry_delete.setFixedWidth(100)
        button_delete = QPushButton("删除订单")
        button_delete.clicked.connect(self.delete_order)

        undo_button = QPushButton("撤销删除")
        undo_button.clicked.connect(self.undo_delete_order)

        button_export = QPushButton("导出订单")
        button_export.clicked.connect(self.export_orders)

        button_price_calculator = QPushButton("价格计算器")
        button_price_calculator.clicked.connect(lambda: self.open_price_calculator())

        button_compare = QPushButton("比较注册信息")  # 新增按钮
        button_compare.clicked.connect(self.compare_with_registration_file)

        layout_buttons.addWidget(self.button_add)
        layout_buttons.addWidget(self.button_update)
        layout_buttons.addWidget(button_search)
        layout_buttons.addWidget(self.entry_search)
        layout_buttons.addWidget(button_delete)
        layout_buttons.addWidget(self.entry_delete)
        layout_buttons.addWidget(undo_button)
        layout_buttons.addWidget(button_export)
        layout_buttons.addWidget(button_price_calculator)
        layout_buttons.addWidget(button_compare)

        self.layout_main.addLayout(layout_buttons)

        # 订单列表显示区域
        display_fields = [field for field in db_fields]
        self.order_table = QTableWidget()
        self.order_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.order_table.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)
        self.order_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.order_table.setColumnCount(len(display_fields))
        self.order_table.setHorizontalHeaderLabels([label_text for label_text, field_name in display_fields])
        self.order_table.verticalHeader().setVisible(False)
        self.order_table.horizontalHeader().setStretchLastSection(True)
        self.order_table.setWordWrap(True)
        self.order_table.resizeColumnsToContents()

        # 连接订单表格的选择信号到处理函数
        self.order_table.selectionModel().selectionChanged.connect(self.on_order_selected)

        self.layout_main.addWidget(self.order_table)

        self.setLayout(self.layout_main)

        self.update_order_table()

    def on_order_selected(self, selected, deselected):
        try:
            indexes = self.order_table.selectionModel().selectedRows()
            if indexes:
                index = indexes[0]
                row = index.row()
                order = purchase_orders[row]
                for field_name, entry in self.entries.items():
                    value = order.get(field_name, "")
                    if isinstance(entry, QComboBox):
                        combo_index = entry.findText(str(value))
                        if combo_index >= 0:
                            entry.setCurrentIndex(combo_index)
                        else:
                            entry.setCurrentText(str(value))
                    else:
                        entry.setText(str(value))
            else:
                for entry in self.entries.values():
                    if isinstance(entry, QComboBox):
                        entry.setCurrentIndex(-1)
                    else:
                        entry.clear()
        except Exception as e:
            print(f"处理订单选择时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"处理订单选择时发生错误：{e}")

    def add_order(self):
        try:
            new_order = {}
            for field_name, entry in self.entries.items():
                if isinstance(entry, QComboBox):
                    value = entry.currentText().strip()
                else:
                    value = entry.text().strip()

                # 数据校验逻辑调整：SKU CLS 应为字符串，不进行整数转换
                # QUANTITY CS 和 BTL PER CS 为整数字段
                # ITEM Name 必填
                # 其他浮点字段进行浮点验证

                if field_name == "SKU CLS":
                    if not value:
                        QMessageBox.warning(self, "输入错误", "SKU CLS 不能为空！")
                        return
                    # SKU CLS 作为字符串，不转换为整数

                elif field_name in ["QUANTITY CS", "BTL PER CS"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = int(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的整数！")
                        return

                elif field_name == "ITEM Name":
                    if not value:
                        QMessageBox.warning(self, "输入错误", "ITEM Name 不能为空！")
                        return

                elif field_name in ["ALC.", "EXW EURO", "Expected Profit", "Domestic Freight CAD", "International Freight EURO", "EXW Exchange Rate", "International Freight Exchange Rate"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = float(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的数字！")
                        return

                new_order[field_name] = value

            # 添加日期
            new_order['date'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # 基本检查
            if not new_order['Order Nb']:
                QMessageBox.warning(self, "添加失败", "订单号不能为空！")
                return

            product_id = new_order.get('Product_ID', '')
            if not product_id:
                QMessageBox.warning(self, "添加失败", "产品编号不能为空！")
                return

            if any(order['Order Nb'] == new_order['Order Nb'] for order in purchase_orders):
                QMessageBox.warning(self, "添加失败", "该订单号已存在！")
                return

            # 在添加订单前，先检查 SKU CLS 对应的产品是否存在
            sku_cls = str(new_order.get('SKU CLS', '')).strip()
            product = get_product_by_sku(sku_cls)
            if not product:
                # 产品不存在，尝试添加产品
                if not self.attempt_add_product_to_management(new_order):
                    # 添加产品失败，直接返回
                    return
                else:
                    # 产品添加成功或者已存在了，现在继续添加订单
                    pass

            # 此时产品已存在，可以继续更新库存和保存订单
            quantity_cs = int(new_order.get('QUANTITY CS', 0))
            btl_per_cs = int(new_order.get('BTL PER CS', 0))
            arrival_date = new_order.get('Arrival_Date', '')
            creation_date = new_order.get('date', '')
            item_name = new_order.get('ITEM Name', '')
            sku_cls = str(new_order.get('SKU CLS', '')).strip()

            update_inventory(
                product_id,
                new_order['Order Nb'],
                quantity_cs,
                arrival_date,
                creation_date,
                item_name,
                sku_cls,
                btl_per_cs,
                operation_type='add_purchase_order'
            )

            purchase_orders.append(new_order)
            save_purchase_order_to_db(new_order)
            data_manager.data_changed.emit()

            self.update_order_table()
            QMessageBox.information(self, "成功", f"订单 {new_order['Order Nb']} 已添加。")

        except Exception as e:
            print(f"添加订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"添加订单时发生错误：{e}")

    def attempt_add_product_to_management(self, order_data):
        """尝试将订单中的产品信息添加到产品列表中（product management）。
           如果添加成功返回 True，失败返回 False。"""
        try:
            # 从订单中获取产品必需信息
            sku_cls = str(order_data.get('SKU CLS', '')).strip()
            item_name = str(order_data.get('ITEM Name', '')).strip()
            category = str(order_data.get('CATEGORY', '')).strip()
            size_str = str(order_data.get('SIZE', '')).strip()
            alc_str = str(order_data.get('ALC.', '')).strip()
            btl_per_cs_str = str(order_data.get('BTL PER CS', '')).strip()
            supplier = str(order_data.get('Supplier', '')).strip()

            # 检查必填字段
            if not sku_cls or not item_name or not category or not size_str or not alc_str or not btl_per_cs_str or not supplier:
                QMessageBox.warning(self, "添加产品失败", "产品信息不完整，无法添加到产品列表中。")
                return False

            # 转换数据类型
            try:
                size = float(size_str)
                alc = float(alc_str)
                btl_per_cs = int(btl_per_cs_str)
            except ValueError:
                QMessageBox.warning(self, "添加产品失败", "Size、ALC、BTL PER CS 必须是有效的数字！")
                return False

            # 检查 SKU_CLS 是否已存在
            if get_product_by_sku(sku_cls) is not None:
                # 已存在，无需重复添加
                return True

            new_product = {
                'SKU_CLS': sku_cls,
                'ITEM_Name': item_name,
                'Category': category,
                'Size': size,
                'ALC': alc,
                'BTL_PER_CS': btl_per_cs,
                'Supplier': supplier,
                'Creation_Date': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }

            save_product_to_db(new_product)

            # 刷新产品列表
            load_products_from_db()

            # 确认添加成功
            if get_product_by_sku(sku_cls) is not None:
                QMessageBox.information(self, "提示", f"产品 {sku_cls} 已成功添加到产品列表中。")
                return True
            else:
                QMessageBox.warning(self, "添加产品失败", "无法在产品列表中找到新添加的产品，请检查数据。")
                return False

        except Exception as e:
            print(f"尝试添加产品到产品管理时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"添加产品到产品列表时发生错误：{e}")
            return False

    def update_order(self):
        try:
            order_nb = self.entries['Order Nb'].text().strip()
            if not order_nb:
                QMessageBox.warning(self, "更新失败", "请输入订单号！")
                return

            # 获取现有订单数据
            existing_order = get_purchase_order_by_nb(order_nb)
            if not existing_order:
                QMessageBox.warning(self, "更新失败", "订单号不存在！")
                return

            # 准备更新后的订单数据
            updated_order = {}
            for field_name, entry in self.entries.items():
                if isinstance(entry, QComboBox):
                    value = entry.currentText().strip()
                else:
                    value = entry.text().strip()

                # 处理需要整数的字段
                if field_name in ["QUANTITY CS", "BTL PER CS", "SKU CLS"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = int(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的整数！")
                        return
               
                elif field_name in ["ITEM Name"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                
                # 处理需要浮点数的字段
                elif field_name in ["ALC.", "EXW EURO", "Expected Profit", "Domestic Freight CAD", "EXW EURO", "International Freight EURO", "EXW Exchange Rate", "International Freight Exchange Rate"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = float(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的数字！")
                        return

                updated_order[field_name] = value

            # 更新日期
            updated_order['date'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # 计算数量差异
            old_quantity_cs = int(existing_order.get('QUANTITY CS', 0))
            new_quantity_cs = int(updated_order.get('QUANTITY CS', 0))
            delta_quantity_cs = new_quantity_cs - old_quantity_cs

            old_btl_per_cs = int(existing_order.get('BTL PER CS', 0))
            new_btl_per_cs = int(updated_order.get('BTL PER CS', 0))
            old_quantity_btl = old_quantity_cs * old_btl_per_cs
            new_quantity_btl = new_quantity_cs * new_btl_per_cs
            delta_quantity_btl = new_quantity_btl - old_quantity_btl

            # 更新库存数量
            product_id = updated_order.get('Product_ID', '')
            arrival_date = updated_order.get('Arrival_Date', '')
            creation_date = updated_order.get('date', '')
            item_name = updated_order.get('ITEM Name', '')
            sku_cls = updated_order.get('SKU CLS', '')
            btl_per_cs = updated_order.get('BTL PER CS', 0)

            update_inventory(
                product_id,
                order_nb,
                delta_quantity_cs,
                arrival_date,
                creation_date,
                item_name,
                sku_cls,
                btl_per_cs,
                operation_type='update_purchase_order'
            )

            # 保存更新后的订单
            index = purchase_orders.index(existing_order)
            purchase_orders[index] = updated_order
            save_purchase_order_to_db(updated_order)
            data_manager.data_changed.emit()

            # 更新库存中的 Arrival_Date
            update_inventory_arrival_date(product_id, order_nb, arrival_date)

            self.update_order_table()
            QMessageBox.information(self, "成功", f"订单 {order_nb} 已更新。")
        except Exception as e:
            print(f"更新订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"更新订单时发生错误：{e}")

    def open_price_calculator(self):
        open_price_calculator(self)

    def find_order(self):
        try:
            search_order_nb = self.entry_search.text().strip()
            if not search_order_nb:
                QMessageBox.warning(self, "查找失败", "请输入要查找的订单号！")
                return
            order = get_purchase_order_by_nb(search_order_nb)
            if order:
                # 在表格中定位并选中该订单
                for row in range(self.order_table.rowCount()):
                    if self.order_table.item(row, 0).text() == search_order_nb:
                        self.order_table.selectRow(row)
                        # 滚动到该行
                        self.order_table.scrollToItem(self.order_table.item(row, 0))
                        break
            else:
                QMessageBox.information(self, "查找结果", f"未找到订单号为 {search_order_nb} 的订单。")
        except Exception as e:
            print(f"查找订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"查找订单时发生错误：{e}")


    def delete_order(self):
        try:
            order_nb = self.entry_delete.text().strip()
            if not order_nb:
                QMessageBox.warning(self, "删除失败", "请输入要删除的订单号！")
                return
            order = get_purchase_order_by_nb(order_nb)
            
            # 调试输出
            print(f"Order data: {order}")
            print(f"Order type: {type(order)}")

            if order:
                # 从采购订单列表中删除
                purchase_orders.remove(order)
                # 添加到已删除订单列表，用于撤销删除
                deleted_orders.append(order)
                # 从数据库中删除
                delete_purchase_order_from_db(order_nb)
                data_manager.data_changed.emit()  # 发射数据变化信号
                # 获取当前库存
                quantity_cs = int(order.get('QUANTITY CS', 0))
                btl_per_cs = int(order.get('BTL PER CS', 0))

                # 减少库存
                update_inventory(
                    order.get('Product_ID', ''),
                    order_nb,
                    -quantity_cs,
                    order.get('Arrival_Date', ''),
                    order.get('date', ''),
                    order.get('ITEM Name', ''),
                    order.get('SKU CLS', ''),
                    btl_per_cs,
                    operation_type='revoke_purchase_order'
                )
                print(f"成功执行update_inventory函数")
                self.update_order_table()
                QMessageBox.information(self, "成功", f"订单 {order_nb} 已删除。")
            else:
                QMessageBox.information(self, "删除失败", f"未找到订单号为 {order_nb} 的订单。")
        except Exception as e:
            print(f"删除订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"删除订单时发生错误：{e}")


    def undo_delete_order(self):
        try:
            if not deleted_orders:
                QMessageBox.information(self, "撤销删除", "没有可撤销的删除操作。")
                return
            # 取出最后一个被删除的订单
            order = deleted_orders.pop()
            # 添加回采购订单列表
            purchase_orders.append(order)
            # 保存到数据库
            save_purchase_order_to_db(order)
            data_manager.data_changed.emit()  # 发射数据变化信号
            # 更新库存
            quantity_cs = int(order.get('QUANTITY CS', 0))
            btl_per_cs = int(order.get('BTL PER CS', 0))
            quantity_btl = quantity_cs * btl_per_cs
            # 增加库存
            update_inventory(
                order.get('Product_ID', ''),
                order['Order Nb'],
                quantity_cs,
                order.get('Arrival_Date', ''),
                order.get('date', ''),
                order.get('ITEM Name', ''),
                order.get('SKU CLS', ''),
                btl_per_cs,
                operation_type='add_purchase_order' #删除订单就会从库存中删除，所以撤销删除订单对库存来说等于新添加
            )
            self.update_order_table()
            QMessageBox.information(self, "成功", f"订单 {order['Order Nb']} 已恢复。")
        except Exception as e:
            print(f"撤销删除时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"撤销删除时发生错误：{e}")


    def export_orders(self):
        try:
            import pandas as pd
            from PyQt6.QtWidgets import QFileDialog
            # 将采购订单转换为 DataFrame
            df = pd.DataFrame(purchase_orders)
            if df.empty:
                QMessageBox.information(self, "导出", "没有可导出的订单数据。")
                return
            # 指定导出的字段顺序
            field_order = [field_name for label_text, field_name in db_fields]
            df = df[field_order]
            # 弹出文件保存对话框
            options = QFileDialog.Option.DontUseNativeDialog  # 根据需要选择选项
            file_name, _ = QFileDialog.getSaveFileName(self, "保存文件", "", "Excel Files (*.xlsx);;All Files (*)", options=options)

            if file_name:
                if not file_name.endswith('.xlsx'):
                    file_name += '.xlsx'
                df.to_excel(file_name, index=False)
                QMessageBox.information(self, "导出成功", f"采购订单已导出到文件 {file_name}")
        except Exception as e:
            print(f"导出订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"导出订单时发生错误：{e}")


    def update_order_table(self):
        # 更新订单表格显示
        display_fields = [field for field in db_fields]
        self.order_table.setRowCount(0)
        self.order_table.setRowCount(len(purchase_orders))
        for row, order in enumerate(purchase_orders):
            for col, (label_text, field_name) in enumerate(display_fields):
                value = order.get(field_name, "")
                item = QTableWidgetItem(str(value))
                self.order_table.setItem(row, col, item)

    def showEvent(self, event):
        super().showEvent(event)
        self.update_order_table()

    def compare_with_registration_file(self):
        try:
            # 获取选定的采购订单
            selected_rows = self.order_table.selectionModel().selectedRows()
            if not selected_rows:
                QMessageBox.warning(self, "提示", "请先选择要比较的采购订单（可多选）。")
                return

            selected_orders = []
            for index in selected_rows:
                row = index.row()
                order = purchase_orders[row]
                selected_orders.append(order)

            # 让用户选择注册文件（Excel 格式）
            options = QFileDialog.Option.DontUseNativeDialog
            file_name, _ = QFileDialog.getOpenFileName(
                self, "选择注册文件", "", "Excel Files (*.xlsx);;All Files (*)", options=options)

            if not file_name:
                return

            # 读取注册文件
            registration_df = pd.read_excel(file_name)

            # 将列名统一转换为小写
            registration_df.columns = registration_df.columns.str.lower()

            # 打印列名调试
            print("读取的注册文件列名：", registration_df.columns.tolist())

            # 确保 'sku cls' 字段存在
            if 'sku cls' not in registration_df.columns:
                QMessageBox.warning(self, "错误", "注册文件中缺少 'SKU CLS' 列。")
                return

            # 将 SKU CLS 转为字符串并统一为小写，便于匹配
            registration_df['sku cls'] = registration_df['sku cls'].astype(str).str.strip().str.lower()

            # 创建一个字典，存储采购订单中的信息，键为 SKU CLS（统一转换为小写）
            po_data = {}
            for order in selected_orders:
                sku_cls = str(order.get('SKU CLS', '')).strip().lower()  # 转换为小写
                po_data[sku_cls] = {
                    'category_po': order.get('CATEGORY', ''),
                    'size_po': order.get('SIZE', ''),
                    'alc_po': order.get('ALC.', ''),
                    'btl per cs_po': order.get('BTL PER CS', ''),
                    'wholesale cs_po': order.get('WHOLESALE CS', ''),
                    'supplier_po': order.get('Supplier', ''),
                    'item name_po': order.get('ITEM Name', ''),
                    'ucc14_po': order.get('UCC14', ''),
                    'ucc13_po': order.get('UCC13', '')
                }


                # 打印 po_data
                print("采购订单数据 po_data：", json.dumps(po_data, indent=2, ensure_ascii=False))


            # 需要比较的字段（统一小写以匹配列名）
            fields_to_compare = ['category', 'size', 'alc', 'btl per cs', 'wholesale cs', 'supplier', 'item name', 'ucc14', 'ucc13' ]

            # 在 DataFrame 中插入采购订单的信息
            for field in fields_to_compare:
                po_field = f"{field}_po"
                # 如果原始注册文件中没有对应的列，跳过
                if field not in registration_df.columns:
                    QMessageBox.warning(self, "错误", f"注册文件中缺少 '{field}' 列。")
                    return
                # 在对应的列右侧插入新列
                col_index = registration_df.columns.get_loc(field) + 1
                registration_df.insert(col_index, po_field, "")

            # 遍历注册文件，填入采购订单的信息并比较
            for idx, row in registration_df.iterrows():
                sku_cls = str(row.get('sku cls', '')).strip().lower()  # 转换为小写
                print(f"注册文件 SKU CLS: {sku_cls}")
                if sku_cls in po_data:
                    print(f"匹配到的采购订单信息: {po_data[sku_cls]}")
                    for field in fields_to_compare:
                        po_field = f"{field}_po"
                        po_value = po_data[sku_cls].get(f"{field}_PO", '')  # 从 po_data 获取值
                        print(f"填入 {field}_PO 的值: {po_value}")
                        registration_df.at[idx, po_field] = po_data[sku_cls].get(f"{field}_po", '')
                else:
                    print(f"未匹配到采购订单信息: {sku_cls}")

            # 保存修改后的 DataFrame 到临时 Excel 文件，以便使用 openpyxl 进行样式处理
            temp_file = 'temp_registration.xlsx'
            registration_df.to_excel(temp_file, index=False)

            # 使用 openpyxl 打开临时文件，处理样式
            wb = load_workbook(temp_file)
            ws = wb.active

            # 定义高亮样式RFA
            fill = PatternFill(start_color='FFFF00', end_color='FFFF00', fill_type='solid')

            # 比较并高亮不一致的单元格
            for idx, row in registration_df.iterrows():
                excel_row = idx + 2  # DataFrame 的索引从 0 开始，Excel 的行从 1 开始，且有标题行
                sku_cls = str(row.get('sku cls', '')).strip().lower()  # 转换为小写
                if sku_cls in po_data:
                    for field in fields_to_compare:
                        po_field = f"{field}_po"
                        reg_value = str(row.get(field, '')).strip()
                        po_value = str(row.get(po_field, '')).strip()
                        if reg_value != po_value:
                            # 高亮注册文件的原始值
                            col_index_reg = registration_df.columns.get_loc(field) + 1  # DataFrame 列索引从 0 开始
                            cell_reg = ws.cell(row=excel_row, column=col_index_reg)
                            cell_reg.fill = fill
                            # 高亮采购订单的值
                            col_index_po = registration_df.columns.get_loc(po_field) + 1
                            cell_po = ws.cell(row=excel_row, column=col_index_po)
                            cell_po.fill = fill

            # 让用户选择保存文件的位置
            save_file_name, _ = QFileDialog.getSaveFileName(
                self, "保存比较结果", "", "Excel Files (*.xlsx);;All Files (*)", options=options)



            print("注册文件列名：", registration_df.columns.tolist())
            print("插入后的列名：", registration_df.columns.tolist())


            if not save_file_name:
                return

            if not save_file_name.endswith('.xlsx'):
                save_file_name += '.xlsx'

            # 保存处理后的工作簿
            wb.save(save_file_name)

            # 删除临时文件
            import os
            os.remove(temp_file)

            QMessageBox.information(self, "成功", f"比较完成，结果已保存到 {save_file_name}")

        except Exception as e:
            print(f"比较时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"比较时发生错误：{e}")
# main.py

from PyQt6.QtWidgets import (
    QApplication, QWidget, QPushButton, QVBoxLayout, QHBoxLayout, QMessageBox
)
import sys

from data import (
    initialize_database,
    load_purchase_orders_from_db,
    load_sales_orders_from_db,
    load_inventory_from_db,
    load_products_from_db  # 新增
)
from order_details import OrderDetailsWindow
from inventory_management import InventoryManagementWindow
from sales_order import SalesOrderWindow
from product_management import ProductManagementWindow  # 新增

# 创建主窗口
app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("订单管理系统")
window.setGeometry(100, 100, 800, 600)

# 程序启动时加载数据
initialize_database()
load_purchase_orders_from_db()
load_sales_orders_from_db()
load_inventory_from_db()
load_products_from_db()  # 新增

# 布局设置
layout_main = QVBoxLayout()

# 按钮区域
layout_buttons = QHBoxLayout()

button_order_details = QPushButton("采购订单管理")
button_order_details.clicked.connect(lambda: open_order_details_window())

button_sales_order = QPushButton("销售订单管理")
button_sales_order.clicked.connect(lambda: open_sales_order_window())

button_inventory_management = QPushButton("库存管理")
button_inventory_management.clicked.connect(lambda: open_inventory_management_window())

button_product_management = QPushButton("产品管理")  # 新增
button_product_management.clicked.connect(lambda: open_product_management_window())  # 新增

layout_buttons.addWidget(button_order_details)
layout_buttons.addWidget(button_sales_order)
layout_buttons.addWidget(button_inventory_management)
layout_buttons.addWidget(button_product_management)  # 新增

layout_main.addLayout(layout_buttons)

# 定义窗口实例
order_details_window = None
sales_order_window = None
inventory_management_window = None
product_management_window = None  # 新增

# 打开采购订单窗口
def open_order_details_window():
    global order_details_window
    try:
        if order_details_window is None:
            order_details_window = OrderDetailsWindow()
        else:
            order_details_window.update_order_table()
        order_details_window.show()
    except Exception as e:
        print(f"打开采购订单窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开采购订单窗口时发生错误：{e}")

# 打开销售订单窗口
def open_sales_order_window():
    global sales_order_window
    try:
        if sales_order_window is None:
            sales_order_window = SalesOrderWindow()
        else:
            sales_order_window.update_sales_order_table()
        sales_order_window.show()
    except Exception as e:
        print(f"打开销售订单窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开销售订单窗口时发生错误：{e}")

# 打开库存管理窗口
def open_inventory_management_window():
    global inventory_management_window
    try:
        if inventory_management_window is None:
            inventory_management_window = InventoryManagementWindow()
        else:
            inventory_management_window.update_inventory_tables()
        inventory_management_window.show()
    except Exception as e:
        print(f"打开库存管理窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开库存管理窗口时发生错误：{e}")

# 打开产品管理窗口
def open_product_management_window():
    global product_management_window
    try:
        if product_management_window is None:
            product_management_window = ProductManagementWindow()
        else:
            product_management_window.update_product_table()
        product_management_window.show()
    except Exception as e:
        print(f"打开产品管理窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开产品管理窗口时发生错误：{e}")

# 设置主布局
window.setLayout(layout_main)
window.show()

if __name__ == "__main__":
    sys.exit(app.exec())
