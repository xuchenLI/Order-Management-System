# sales_order.py

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QGridLayout, QComboBox, QListWidget, QAbstractItemView, QListWidgetItem, QApplication
)
from PyQt6.QtGui import QShortcut, QKeySequence
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import QInputDialog
import datetime
from data import (
    sales_orders, save_sales_order_to_db, delete_sales_order_from_db,
    load_sales_orders_from_db, get_btl_per_cs, restore_inventory, data_manager, inventory, update_inventory, get_inventory_info, purchase_orders
)
from data import get_purchase_order_by_product_id
import re
from data import get_inventory_item
from data import load_sales_orders_from_db, data_manager


class SalesOrderWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("销售订单管理")
        self.setGeometry(200, 200, 1000, 600)
        self.last_deleted_order = None  # 用于保存上次删除的订单
        self.layout_main = QVBoxLayout()

        self.layout_inputs = QGridLayout()
        self.entries = {}

        fields = [
            ('销售订单号', 'Sales_ID'),
            ('产品编号', 'Product_ID'),
            ('订单号','Order_Nb'),
            ('客户编号', 'Customer_ID'),
            ('销售箱数', 'Quantity_CS_Sold'),
            ('单瓶售价(€)', 'Price_per_bottle'),
        ]

        for row, (label_text, field_name) in enumerate(fields):
            label = QLabel(label_text + ":")
            label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            if field_name == 'Product_ID':
                entry = QComboBox()
                entry.setEditable(True)  # 设置为可编辑
                # 获取完整的产品编号列表，并保存为成员变量
                self.full_product_ids = self.get_all_product_ids()
                # 添加空项以及全部产品编号
                entry.addItem('')
                entry.addItems(self.full_product_ids)
                # 连接下拉框文本变化信号，进行模糊搜索过滤
                entry.lineEdit().textChanged.connect(self.filter_product_ids)
                entry.currentIndexChanged.connect(self.on_product_id_changed)
            elif field_name == 'Order_Nb':
                entry = QListWidget()
                entry.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
                entry.setFixedHeight(100)
                entry.itemSelectionChanged.connect(self.update_available_stock)
            else:
                entry = QLineEdit()
            entry.setFixedWidth(300)
            entry.setStyleSheet("border: 1px solid lightgray;")
            self.entries[field_name] = entry
            self.layout_inputs.addWidget(label, row, 0)
            self.layout_inputs.addWidget(entry, row, 1)
            if field_name == 'Quantity_CS_Sold':
                self.available_cs_label = QLabel("可用箱数: 0")
                self.available_cs_label.setStyleSheet("color: gray; font-style: italic;")
                self.layout_inputs.addWidget(self.available_cs_label, row, 2)

        label_btl_per_cs = QLabel("每箱瓶数:")
        label_btl_per_cs.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.label_btl_per_cs_value = QLabel("0")
        self.layout_inputs.addWidget(label_btl_per_cs, len(fields), 0)
        self.layout_inputs.addWidget(self.label_btl_per_cs_value, len(fields), 1)

        self.layout_main.addLayout(self.layout_inputs)

        layout_buttons = QHBoxLayout()

        self.button_add = QPushButton("添加销售订单")
        self.button_add.clicked.connect(self.add_sales_order)
        self.button_update = QPushButton("更新销售订单")
        self.button_update.clicked.connect(self.update_sales_order)
        self.button_delete = QPushButton("删除销售订单")
        self.button_delete.clicked.connect(self.delete_sales_order)
        self.button_undo_delete = QPushButton("撤销删除")
        self.button_undo_delete.clicked.connect(self.undo_last_deletion)

        layout_buttons.addWidget(self.button_add)
        layout_buttons.addWidget(self.button_update)
        layout_buttons.addWidget(self.button_delete)
        layout_buttons.addWidget(self.button_undo_delete)
        self.layout_main.addLayout(layout_buttons)

        # 增加排序和过滤区域
        filter_sort_layout = QHBoxLayout()

        sort_label = QLabel("排序规则:")
        self.sort_combo = QComboBox()
        self.sort_combo.addItems(["按订单日期", "按客户编号", "按销售订单号", "按采购订单号", "按产品编号", "按产品名称", "按总金额"])
        self.sort_combo.currentIndexChanged.connect(self.update_sales_order_table)
        filter_sort_layout.addWidget(sort_label)
        filter_sort_layout.addWidget(self.sort_combo)

        filter_field_label = QLabel("过滤条件:")
        self.filter_field_combo = QComboBox()
        self.filter_field_combo.addItems(["按订单日期", "按客户编号", "按采购订单号", "按产品编号", "按产品名称"])
        filter_sort_layout.addWidget(filter_field_label)
        filter_sort_layout.addWidget(self.filter_field_combo)

        self.filter_field_input = QLineEdit()
        self.filter_field_input.setPlaceholderText("输入过滤内容(支持*通配符)")
        self.filter_field_input.textChanged.connect(self.update_sales_order_table)
        filter_sort_layout.addWidget(self.filter_field_input)

        self.layout_main.addLayout(filter_sort_layout)

        self.table_fields = [
            ('客户编号', 'Customer_ID'),
            ('销售订单号', 'Sales_ID'),
            ('采购订单号', 'Order_Nb'),
            ('SKU CLS', 'SKU_CLS'),
            ('产品编号', 'Product_ID'),
            ('产品名称', 'Product_Name'),
            ('销售箱数', 'Quantity_CS_Sold'),
            ('BTL PER CS', 'BTL_PER_CS'),
            ('总销售瓶数', 'Total_Quantity_BTL_Sold'),
            ('单瓶售价(€)', 'Price_per_bottle'),
            ('总金额(€)', 'Total_Amount'),
            ('订单日期', 'Order_Date'),
            ('备注', 'Remarks')
        ]
        self.sales_order_table = QTableWidget()
        # 设置表格为单元格选择并允许拖动选择多个单元格
        self.sales_order_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectItems)
        self.sales_order_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.sales_order_table.setColumnCount(len(self.table_fields))
        self.sales_order_table.setHorizontalHeaderLabels([label_text for label_text, field_name in self.table_fields])
        self.sales_order_table.verticalHeader().setVisible(False)
        self.sales_order_table.horizontalHeader().setStretchLastSection(True)
        self.sales_order_table.setWordWrap(True)
        self.sales_order_table.resizeColumnsToContents()
        self.sales_order_table.itemChanged.connect(self.on_item_changed)
        self.sales_order_table.selectionModel().selectionChanged.connect(self.on_order_selected)
        self.layout_main.addWidget(self.sales_order_table)

        # 添加复制快捷键：在表格初始化完成之后
        self.copy_shortcut = QShortcut(QKeySequence(QKeySequence.StandardKey.Copy), self.sales_order_table)
        self.copy_shortcut.activated.connect(self.copySelectedCells)
        self.clear_selection_shortcut = QShortcut(QKeySequence("Escape"), self.sales_order_table)
        self.clear_selection_shortcut.activated.connect(lambda: self.sales_order_table.clearSelection())


        self.setLayout(self.layout_main)

        # 加载订单数据并更新表格
        load_sales_orders_from_db()
        self.update_sales_order_table()
        data_manager.inventory_changed.connect(self.on_inventory_changed)

        # 初始化产品编号相关操作
        self.on_product_id_changed()

    # 实现复制选中单元格内容到剪贴板的函数
    def copySelectedCells(self):
        selected_ranges = self.sales_order_table.selectedRanges()
        if not selected_ranges:
            return
        copied_text = ""
        for selection in selected_ranges:
            for row in range(selection.topRow(), selection.bottomRow() + 1):
                row_data = []
                for col in range(selection.leftColumn(), selection.rightColumn() + 1):
                    item = self.sales_order_table.item(row, col)
                    row_data.append(item.text() if item else "")
                copied_text += "\t".join(row_data) + "\n"
        clipboard = QApplication.clipboard()
        clipboard.setText(copied_text)


    def filter_product_ids(self, text):
        """
        根据用户输入的 text 对产品编号进行模糊匹配，并更新下拉列表显示的内容，
        支持使用 '*' 作为通配符进行匹配。匹配方式为只要产品编号中含有符合模式的子串即可匹配。
        """
        product_combo: QComboBox = self.entries['Product_ID']
        # 阻塞 QLineEdit 信号，避免递归触发
        product_combo.lineEdit().blockSignals(True)
        
        current_text = text
        product_combo.clear()
        product_combo.addItem('')  # 保留空选项

        if '*' in current_text:
            # 将输入文本转换为正则表达式模式
            # 使用 re.escape 对普通字符进行转义，然后将转义后的 '*' 替换为 '.*'
            # 不加锚点，这样只匹配产品编号中任意位置的匹配项
            pattern = re.escape(current_text).replace(r'\*', '.*')
            regex = re.compile(pattern, re.IGNORECASE)
            filtered_ids = [pid for pid in self.full_product_ids if regex.search(pid)]
        else:
            # 普通的包含匹配（忽略大小写）
            filtered_ids = [pid for pid in self.full_product_ids if current_text.lower() in pid.lower()]

        product_combo.addItems(filtered_ids)
        
        # 恢复用户输入的文本和光标位置
        product_combo.lineEdit().setText(current_text)
        product_combo.lineEdit().setCursorPosition(len(current_text))
        
        # 恢复 QLineEdit 信号
        product_combo.lineEdit().blockSignals(False)
        
        # 更新产品编号变更后的相关逻辑
        self.on_product_id_changed()




    def on_item_changed(self, item):
        column = item.column()
        remarks_col = self.field_index('Remarks')
        if column == remarks_col:
            new_remarks = item.text()
            sales_id_item = self.sales_order_table.item(item.row(), self.field_index('Sales_ID'))
            if sales_id_item:
                sales_id = sales_id_item.text()
                order = next((o for o in sales_orders if o['Sales_ID'] == sales_id), None)
                if order:
                    order['Remarks'] = new_remarks
                    save_sales_order_to_db(order)

    def field_index(self, field_name):
        for index, (label, field) in enumerate(self.table_fields):
            if field == field_name:
                return index
        return None

    def on_inventory_changed(self):
        self.update_product_ids()

    def update_product_ids(self):
        current_product_id = self.entries['Product_ID'].currentText()
        product_ids = self.get_all_product_ids()
        self.entries['Product_ID'].clear()
        for pid in product_ids:
            self.entries['Product_ID'].addItem(pid)

        if current_product_id in product_ids:
            idx = product_ids.index(current_product_id)
            self.entries['Product_ID'].setCurrentIndex(idx)
        else:
            self.entries['Product_ID'].setCurrentIndex(0)
        self.on_product_id_changed()

    def update_order_nb_list(self, product_id):
        self.entries['Order_Nb'].clear()
        order_nbs = self.get_order_nbs_by_product_id(product_id)
        for order_nb, arrival_date in order_nbs:
            display_text = f"{order_nb}"
            item = QListWidgetItem(display_text)
            item.setData(Qt.ItemDataRole.UserRole, order_nb)
            self.entries['Order_Nb'].addItem(item)

    def update_available_stock(self):
        selected_items = self.entries['Order_Nb'].selectedItems()
        selected_order_nbs = [item.data(Qt.ItemDataRole.UserRole) for item in selected_items]

        total_available_cs = 0
        btl_per_cs_values = []

        for item in inventory:
            if item['Order_Nb'] in selected_order_nbs:
                current_stock_cs = int(item.get('Current_Stock_CS', 0))
                total_available_cs += current_stock_cs
                btl_val = int(item.get('BTL PER CS', 0))
                if btl_val not in btl_per_cs_values:
                    btl_per_cs_values.append(btl_val)

        self.available_cs_label.setText(f"可用箱数: {total_available_cs}")
        if btl_per_cs_values:
            self.label_btl_per_cs_value.setText(", ".join(map(str, sorted(btl_per_cs_values))))
        else:
            self.label_btl_per_cs_value.setText("0")

    def get_order_nbs_by_product_id(self, product_id):
        order_list = []
        for item_ in inventory:
            if item_['Product_ID'] == product_id:
                current_stock_cs = int(item_.get('Current_Stock_CS',0))
                if current_stock_cs > 0:
                    order_nb = item_['Order_Nb']
                    arrival_date = item_.get('Arrival_Date','')
                    order_list.append((order_nb, arrival_date))
        order_list.sort(key=lambda x: x[1])
        return order_list

    def get_all_product_ids(self):
        product_dict = {}
        for item in inventory:
            pid = item['Product_ID']
            key = pid.lower()  # 归一化为小写作为键
            if key not in product_dict:
                product_dict[key] = pid  # 保留原始形式（或你想显示的格式）
        # 返回时按照小写排序
        return sorted(list(product_dict.values()), key=lambda x: x.lower())

    def on_product_id_changed(self):
        product_id = self.entries['Product_ID'].currentText()
        btl_per_cs = get_btl_per_cs(product_id)
        self.label_btl_per_cs_value.setText(str(btl_per_cs))
        self.update_order_nb_list(product_id)
        self.update_available_stock()

    def on_order_selected(self, selected, deselected):
        indexes = self.sales_order_table.selectionModel().selectedIndexes()
        if indexes:
            # 取第一个选中单元格所在的行
            row = indexes[0].row()
            fs_orders = self.get_filtered_and_sorted_sales_orders()
            order = fs_orders[row]
            for field_name, entry in self.entries.items():
                if field_name == 'Order_Nb':
                    order_nbs = order.get('Order_Nb', '').split(',')
                    entry.clearSelection()
                    for i in range(entry.count()):
                        item = entry.item(i)
                        if item.data(Qt.ItemDataRole.UserRole) in order_nbs:
                            item.setSelected(True)
                elif field_name == 'Product_ID':
                    idx = entry.findText(order.get('Product_ID', ''))
                    if idx >= 0:
                        entry.setCurrentIndex(idx)
                else:
                    value = order.get(field_name, '')
                    entry.setText(str(value))
            self.update_available_stock()


    def add_sales_order(self):

        try:
            new_order = {}
            for field_name, entry in self.entries.items():
                if isinstance(entry, QComboBox):
                    value = entry.currentText().strip()
                elif isinstance(entry, QListWidget):
                    selected_items = entry.selectedItems()
                    selected_order_nbs = [it.data(Qt.ItemDataRole.UserRole) for it in selected_items]
                    if not selected_order_nbs:
                        QMessageBox.warning(self, "添加失败", "请至少选择一个订单号！")
                        return
                    value = ','.join(selected_order_nbs)
                else:
                    value = entry.text().strip()
                new_order[field_name] = value

            # 检查销售订单号是否重复
            sales_id = new_order.get('Sales_ID', '')
            if any(o['Sales_ID'] == sales_id for o in sales_orders):
                QMessageBox.warning(self, "添加失败", f"销售订单号 {sales_id} 已存在！")
                return

            new_order['Order_Date'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            new_order['Shipped_Date'] = ''

            quantity_cs_sold = int(new_order['Quantity_CS_Sold']) if new_order['Quantity_CS_Sold'] else 0
            selected_order_nbs = new_order['Order_Nb'].split(',')
            product_id = new_order.get('Product_ID')
            if selected_order_nbs:
                product_name, btl_per_cs = get_inventory_info(product_id, selected_order_nbs[0])
            else:
                product_name, btl_per_cs = '', 0
            new_order['Product_Name'] = product_name
            new_order['BTL_PER_CS'] = btl_per_cs

            price_per_bottle = float(new_order['Price_per_bottle']) if new_order['Price_per_bottle'] else 0.0
            if price_per_bottle == 0.0:
                QMessageBox.warning(self, "添加失败", "单瓶售价不能为0！")
                return

            total_available_cs = 0
            for order_nb in selected_order_nbs:
                inventory_item = next((item for item in inventory if item['Order_Nb'] == order_nb), None)
                if inventory_item:
                    current_stock_cs = int(inventory_item.get('Current_Stock_CS', 0))
                    total_available_cs += current_stock_cs

            if total_available_cs < quantity_cs_sold:
                QMessageBox.warning(self, "库存不足", f"库存不足！可用: {total_available_cs}箱，需要: {quantity_cs_sold}箱")
                return

            deduction_details = []
            remaining_cs_to_sell = quantity_cs_sold
            total_amount = 0.0
            total_btl = 0

            for order_nb in selected_order_nbs:
                inventory_item = next((item for item in inventory if item['Order_Nb'] == order_nb), None)
                if not inventory_item:
                    continue
                btl_per_cs_order = int(inventory_item['BTL PER CS'])
                current_stock_cs = int(inventory_item['Current_Stock_CS'])

                if remaining_cs_to_sell <= current_stock_cs:
                    deduct_cs = remaining_cs_to_sell
                    update_inventory(
                        new_order['Product_ID'],
                        order_nb,
                        -deduct_cs,
                        inventory_item.get('Arrival_Date'),
                        inventory_item.get('Creation_Date'),
                        inventory_item.get('Product_Name'),
                        inventory_item.get('SKU_CLS'),
                        btl_per_cs_order,
                        operation_type='sales',
                        sale_date=new_order['Order_Date'],
                        sales_orders=new_order['Sales_ID']
                    )
                    deduction_details.append({'Order_Nb': order_nb, 'Deduct_CS': deduct_cs})
                    total_amount += deduct_cs * btl_per_cs_order * price_per_bottle
                    total_btl += deduct_cs * btl_per_cs_order
                    remaining_cs_to_sell = 0
                    break
                else:
                    deduct_cs = current_stock_cs
                    update_inventory(
                        new_order['Product_ID'],
                        order_nb,
                        -deduct_cs,
                        inventory_item.get('Arrival_Date'),
                        inventory_item.get('Creation_Date'),
                        inventory_item.get('Product_Name'),
                        inventory_item.get('SKU_CLS'),
                        btl_per_cs_order,
                        operation_type='sales',
                        sale_date=new_order['Order_Date'],
                        sales_orders=new_order['Sales_ID']
                    )
                    deduction_details.append({'Order_Nb': order_nb, 'Deduct_CS': deduct_cs})
                    total_amount += deduct_cs * btl_per_cs_order * price_per_bottle
                    total_btl += deduct_cs * btl_per_cs_order
                    remaining_cs_to_sell -= deduct_cs

            new_order['Deduction_Details'] = deduction_details
            new_order['Total_Amount'] = total_amount
            new_order['Total_Quantity_BTL_Sold'] = total_btl

            sales_orders.append(new_order)
            save_sales_order_to_db(new_order)
            self.update_sales_order_table()
            QMessageBox.information(self, "成功", f"销售订单 {new_order['Sales_ID']} 已添加，总金额：{total_amount:.2f} €")

        except Exception as e:
            print(f"添加销售订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"添加销售订单时发生错误：{e}")

    def update_sales_order(self):
        # 您可根据需要实现更新逻辑
        print("功能开发中")

    def delete_sales_order(self):
        """
        通过输入销售订单号删除订单，一次只能输入一个。
        删除时调用 restore_inventory 将扣减的库存恢复，
        并将删除的订单保存到 self.last_deleted_order 中，便于撤销删除。
        """
        order_id, ok = QInputDialog.getText(self, "删除销售订单", "请输入要删除的销售订单号：")
        if not ok or not order_id.strip():
            return

        order_id = order_id.strip()
        # 如果输入中包含逗号或者空格，认为用户输入了多个订单号
        if ',' in order_id or ' ' in order_id:
            QMessageBox.warning(self, "删除错误", "一次只能输入一个销售订单号！")
            return

        # 在销售订单列表中查找对应订单
        order = next((o for o in sales_orders if o['Sales_ID'] == order_id), None)
        if not order:
            QMessageBox.warning(self, "删除错误", f"找不到销售订单号：{order_id}")
            return

        try:
            # 先恢复库存，即将订单中扣减的库存返还
            restore_inventory(order)
            # 删除订单：从内存和数据库中移除
            sales_orders.remove(order)
            delete_sales_order_from_db(order_id)
            # 保存删除的订单信息，便于撤销删除
            self.last_deleted_order = order.copy()
            self.update_sales_order_table()
            QMessageBox.information(self, "成功", f"销售订单 {order_id} 已删除。")
        except Exception as e:
            print(f"删除销售订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"删除销售订单时发生错误：{e}")

    def reapply_inventory_deduction(self, order):
        """
        根据订单中的扣减详情，重新扣减库存，
        实现撤销删除后恢复销售订单时的库存扣减操作。
        """
        product_id = order.get('Product_ID')
        order_date = order.get('Order_Date')
        sales_id = order.get('Sales_ID')
        deduction_details = order.get('Deduction_Details', [])
        if not deduction_details:
            # 如果订单中没有扣减详情，不做处理
            return

        for deduction in deduction_details:
            order_nb = deduction.get('Order_Nb')
            deduct_cs = deduction.get('Deduct_CS', 0)
            # 查找对应的库存记录
            inventory_item = get_inventory_item(product_id, order_nb)
            if not inventory_item:
                # 如果找不到库存记录，则提示或跳过
                print(f"找不到库存记录，产品ID: {product_id}, 订单号: {order_nb}")
                continue
            btl_per_cs = int(inventory_item.get('BTL PER CS', 0))
            arrival_date = inventory_item.get('Arrival_Date')
            creation_date = inventory_item.get('Creation_Date')
            product_name = inventory_item.get('Product_Name')
            sku_cls = inventory_item.get('SKU_CLS')
            # 重新扣减库存，即库存变化量为负的扣减数量
            update_inventory(
                product_id,
                order_nb,
                -deduct_cs,  # 负数表示扣减库存
                arrival_date,
                creation_date,
                product_name,
                sku_cls,
                btl_per_cs,
                operation_type='sales',
                sale_date=order_date,
                sales_orders=sales_id
            )

    def undo_last_deletion(self):
        """
        撤销上一次删除的销售订单：
        1. 将订单恢复到内存和数据库中。
        2. 根据订单的扣减详情重新扣减库存（撤销恢复库存）。
        """
        if not self.last_deleted_order:
            QMessageBox.warning(self, "撤销错误", "没有可撤销的删除操作。")
            return
        try:
            order = self.last_deleted_order
            # 将订单恢复到内存中，并保存到数据库
            sales_orders.append(order)
            save_sales_order_to_db(order)
            # 重新扣减库存：撤销删除时，需要重新扣减与该订单对应的库存
            self.reapply_inventory_deduction(order)
            self.last_deleted_order = None  # 清除上次删除记录
            self.update_sales_order_table()
            QMessageBox.information(self, "成功", f"销售订单 {order['Sales_ID']} 已恢复，库存已更新。")
        except Exception as e:
            print(f"恢复销售订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"恢复销售订单时发生错误：{e}")

    def get_filtered_and_sorted_sales_orders(self):
        filtered = sales_orders.copy()
        filter_field = self.filter_field_combo.currentText()
        filter_value = self.filter_field_input.text().strip()

        if filter_value:
            pattern = None
            if '*' in filter_value:
                pattern = re.escape(filter_value).replace(r'\*', '.*')
                regex = re.compile(pattern, re.IGNORECASE)
            def match_field(val):
                if pattern:
                    return bool(regex.search(str(val)))
                else:
                    return filter_value.lower() in str(val).lower()

            if filter_field == "按订单日期":
                filtered = [o for o in filtered if match_field(o.get('Order_Date',''))]
            elif filter_field == "按客户编号":
                filtered = [o for o in filtered if match_field(o.get('Customer_ID',''))]
            elif filter_field == "按采购订单号":
                filtered = [o for o in filtered if match_field(o.get('Order_Nb',''))]
            elif filter_field == "按产品编号":
                filtered = [o for o in filtered if match_field(o.get('Product_ID',''))]
            elif filter_field == "按产品名称":
                filtered = [o for o in filtered if match_field(o.get('Product_Name',''))]

        sort_option = self.sort_combo.currentText()
        def sort_key(o):
            if sort_option == "按订单日期":
                return o.get('Order_Date','')
            elif sort_option == "按客户编号":
                return o.get('Customer_ID','')
            elif sort_option == "按销售订单号":
                return o.get('Sales_ID','')
            elif sort_option == "按采购订单号":
                return o.get('Order_Nb','')
            elif sort_option == "按产品编号":
                return o.get('Product_ID','')
            elif sort_option == "按产品名称":
                return o.get('Product_Name','')
            elif sort_option == "按总金额":
                try:
                    return float(o.get('Total_Amount',0))
                except:
                    return 0
            return ''

        filtered = sorted(filtered, key=sort_key)
        return filtered

    def update_sales_order_table(self):
        self.sales_order_table.blockSignals(True)

        filtered_sorted_orders = self.get_filtered_and_sorted_sales_orders()
        self.sales_order_table.setRowCount(0)
        self.sales_order_table.setRowCount(len(filtered_sorted_orders))
        for row, order in enumerate(filtered_sorted_orders):
            for col, (label_text, field_name) in enumerate(self.table_fields):
                if field_name == 'SKU_CLS':
                    # 根据订单中的产品编号，从对应的采购订单中提取 SKU CLS
                    purchase_order = get_purchase_order_by_product_id(order.get("Product_ID", ""))
                    value = purchase_order.get("SKU CLS", "") if purchase_order else ""
                else:
                    value = order.get(field_name, "")
                item = QTableWidgetItem(str(value))
                if field_name == 'Remarks':
                    item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
                else:
                    item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)
                self.sales_order_table.setItem(row, col, item)


        self.sales_order_table.blockSignals(False)
# product_management.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QGridLayout, QComboBox
)
from PyQt6.QtCore import Qt
import datetime
import re

from data import (
    products, save_product_to_db, delete_product_from_db,
    load_products_from_db, data_manager, get_product_by_sku
)

class ProductManagementWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("产品管理")
        self.setGeometry(200, 200, 800, 600)

        self.layout_main = QVBoxLayout()

        # 输入区域
        self.layout_inputs = QGridLayout()
        self.entries = {}

        fields = [
            ('SKU CLS', 'SKU_CLS'),
            ('ITEM Name', 'ITEM_Name'),
            ('Category', 'Category'),
            ('Size', 'Size'),
            ('ALC.', 'ALC'),
            ('BTL PER CS', 'BTL_PER_CS'),
            ('Supplier', 'Supplier'),
        ]

        for row, (label_text, field_name) in enumerate(fields):
            label = QLabel(label_text + ":")
            label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            entry = QLineEdit()
            entry.setFixedWidth(300)
            entry.setStyleSheet("border: 1px solid lightgray;")
            self.entries[field_name] = entry
            self.layout_inputs.addWidget(label, row, 0)
            self.layout_inputs.addWidget(entry, row, 1)

        self.layout_main.addLayout(self.layout_inputs)

        # 按钮区域
        layout_buttons = QHBoxLayout()

        self.button_add = QPushButton("添加产品")
        self.button_add.clicked.connect(self.add_product)
        self.button_update = QPushButton("更新产品")
        self.button_update.clicked.connect(self.update_product)
        self.button_delete = QPushButton("删除产品")
        self.button_delete.clicked.connect(self.delete_product)

        layout_buttons.addWidget(self.button_add)
        layout_buttons.addWidget(self.button_update)
        layout_buttons.addWidget(self.button_delete)

        self.layout_main.addLayout(layout_buttons)

        # 添加排序和过滤区域
        control_layout = QHBoxLayout()

        # 排序选项
        sort_label = QLabel("排序规则:")
        self.sort_combo = QComboBox()
        # 定义产品管理的排序选项
        self.sort_combo.addItems(["按SKU CLS", "按产品名称", "按Supplier", "按BTL PER CS", "按创建日期"])
        self.sort_combo.currentIndexChanged.connect(self.update_product_table)

        control_layout.addWidget(sort_label)
        control_layout.addWidget(self.sort_combo)

        # 过滤选项
        filter_field_label = QLabel("过滤条件:")
        self.filter_field_combo = QComboBox()
        self.filter_field_combo.addItems(["按SKU CLS", "按产品名称", "按Supplier"])
        self.filter_field_combo.currentIndexChanged.connect(self.update_product_table)

        self.filter_field_input = QLineEdit()
        self.filter_field_input.setPlaceholderText("输入过滤内容(支持*通配符)")
        self.filter_field_input.textChanged.connect(self.update_product_table)
        self.filter_field_input.setFixedWidth(200)

        control_layout.addWidget(filter_field_label)
        control_layout.addWidget(self.filter_field_combo)
        control_layout.addWidget(self.filter_field_input)

        control_layout.addStretch(1)

        self.layout_main.addLayout(control_layout)

        # 产品列表显示区域
        self.product_table = QTableWidget()
        self.product_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.product_table.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)
        self.product_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.product_table.setColumnCount(8)
        self.product_table.setHorizontalHeaderLabels([
            'SKU CLS', 'ITEM Name', 'Category', 'Size', 'ALC.', 'BTL PER CS', 'Supplier', '创建日期'
        ])
        self.product_table.verticalHeader().setVisible(False)
        self.product_table.horizontalHeader().setStretchLastSection(True)
        self.product_table.setWordWrap(True)
        self.product_table.resizeColumnsToContents()

        # 连接产品表格的选择信号到处理函数
        self.product_table.selectionModel().selectionChanged.connect(self.on_product_selected)

        self.layout_main.addWidget(self.product_table)

        self.setLayout(self.layout_main)

        # 加载产品数据
        load_products_from_db()
        self.update_product_table()

        # 连接数据变化信号到更新方法
        data_manager.products_changed.connect(self.update_product_table)

    def on_product_selected(self, selected, deselected):
        try:
            indexes = self.product_table.selectionModel().selectedRows()
            if indexes:
                index = indexes[0]
                row = index.row()
                # 根据当前显示的产品列表获取产品
                # 因为update_product_table会根据过滤排序产生一个局部列表，所以需要在方法中保留这个列表
                # 在这里我们再次调用 get_filtered_and_sorted_products 获取当前显示的列表
                displayed_products = self.get_filtered_and_sorted_products()
                product = displayed_products[row]

                for field_name, entry in self.entries.items():
                    value = product.get(field_name, "")
                    entry.setText(str(value))
            else:
                for entry in self.entries.values():
                    entry.clear()
        except Exception as e:
            print(f"处理产品选择时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"处理产品选择时发生错误：{e}")

    def get_filtered_and_sorted_products(self):
        # 根据过滤和排序条件，返回处理后的产品列表
        filtered_products = products.copy()

        # 获取过滤条件
        filter_field = self.filter_field_combo.currentText()
        filter_value = self.filter_field_input.text().strip()

        # 执行过滤逻辑
        if filter_value:
            # 如果包含'*'，需要模糊匹配
            if '*' in filter_value:
                pattern = re.escape(filter_value).replace(r'\*', '.*')
                regex = re.compile(pattern, re.IGNORECASE)
            
            if filter_field == "按SKU CLS":
                if '*' in filter_value:
                    filtered_products = [p for p in filtered_products if regex.search(p.get('SKU_CLS', ''))]
                else:
                    filtered_products = [p for p in filtered_products if filter_value.lower() in p.get('SKU_CLS', '').lower()]
            elif filter_field == "按产品名称":
                # 产品名称对ITEM_Name字段过滤
                if '*' in filter_value:
                    filtered_products = [p for p in filtered_products if regex.search(p.get('ITEM_Name', ''))]
                else:
                    filtered_products = [p for p in filtered_products if filter_value.lower() in p.get('ITEM_Name', '').lower()]
            elif filter_field == "按Supplier":
                if '*' in filter_value:
                    filtered_products = [p for p in filtered_products if regex.search(p.get('Supplier', ''))]
                else:
                    filtered_products = [p for p in filtered_products if filter_value.lower() in p.get('Supplier', '').lower()]

        # 获取排序规则
        sort_option = self.sort_combo.currentText()
        if sort_option == "按SKU CLS":
            filtered_products = sorted(filtered_products, key=lambda x: x.get('SKU_CLS', ''))
        elif sort_option == "按产品名称":
            filtered_products = sorted(filtered_products, key=lambda x: x.get('ITEM_Name', ''))
        elif sort_option == "按Supplier":
            filtered_products = sorted(filtered_products, key=lambda x: x.get('Supplier', ''))
        elif sort_option == "按BTL PER CS":
            filtered_products = sorted(filtered_products, key=lambda x: int(x.get('BTL_PER_CS', 0)))
        elif sort_option == "按创建日期":
            # Creation_Date格式为 "YYYY-MM-DD HH:MM:SS"，字符串比较即可按时间顺序排序
            filtered_products = sorted(filtered_products, key=lambda x: x.get('Creation_Date', ''))

        return filtered_products

    def update_product_table(self):
        # 在更新表格显示前，获取过滤和排序后的产品列表
        displayed_products = self.get_filtered_and_sorted_products()

        self.product_table.setRowCount(0)
        self.product_table.setRowCount(len(displayed_products))
        for row, product in enumerate(displayed_products):
            self.product_table.setItem(row, 0, QTableWidgetItem(product.get('SKU_CLS', '')))
            self.product_table.setItem(row, 1, QTableWidgetItem(product.get('ITEM_Name', '')))
            self.product_table.setItem(row, 2, QTableWidgetItem(product.get('Category', '')))
            self.product_table.setItem(row, 3, QTableWidgetItem(str(product.get('Size', ''))))
            self.product_table.setItem(row, 4, QTableWidgetItem(str(product.get('ALC', ''))))
            self.product_table.setItem(row, 5, QTableWidgetItem(str(product.get('BTL_PER_CS', ''))))
            self.product_table.setItem(row, 6, QTableWidgetItem(product.get('Supplier', '')))
            self.product_table.setItem(row, 7, QTableWidgetItem(product.get('Creation_Date', '')))

    def add_product(self):
        try:
            new_product = {}
            for field_name, entry in self.entries.items():
                value = entry.text().strip()
                if not value:
                    QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                    return
                new_product[field_name] = value

            # 检查 SKU_CLS 是否已存在
            sku_cls = new_product['SKU_CLS']
            if any(product['SKU_CLS'] == sku_cls for product in products):
                QMessageBox.warning(self, "添加失败", f"产品 {sku_cls} 已存在！")
                return

            # 转换数据类型
            try:
                new_product['Size'] = float(new_product['Size'])
                new_product['ALC'] = float(new_product['ALC'])
                new_product['BTL_PER_CS'] = int(new_product['BTL_PER_CS'])
            except ValueError:
                QMessageBox.warning(self, "输入错误", "Size、ALC.、BTL PER CS 必须是有效的数字！")
                return

            new_product['Creation_Date'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            products.append(new_product)
            save_product_to_db(new_product)
            data_manager.products_changed.emit()

            self.update_product_table()
            QMessageBox.information(self, "成功", f"产品 {sku_cls} 已添加。")
        except Exception as e:
            print(f"添加产品时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"添加产品时发生错误：{e}")

    def update_product(self):
        try:
            sku_cls = self.entries['SKU_CLS'].text().strip()
            if not sku_cls:
                QMessageBox.warning(self, "更新失败", "请输入 SKU CLS！")
                return

            # 获取现有产品数据
            existing_product = get_product_by_sku(sku_cls)
            if not existing_product:
                QMessageBox.warning(self, "更新失败", f"产品 {sku_cls} 不存在！")
                return

            # 准备更新后的产品数据
            updated_product = {}
            for field_name, entry in self.entries.items():
                value = entry.text().strip()
                if not value:
                    QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                    return
                updated_product[field_name] = value

            # 转换数据类型
            try:
                updated_product['Size'] = float(updated_product['Size'])
                updated_product['ALC'] = float(updated_product['ALC'])
                updated_product['BTL_PER_CS'] = int(updated_product['BTL_PER_CS'])
            except ValueError:
                QMessageBox.warning(self, "输入错误", "Size、ALC.、BTL PER CS 必须是有效的数字！")
                return

            # 保留创建日期
            updated_product['Creation_Date'] = existing_product['Creation_Date']

            # 更新产品列表和数据库
            index = products.index(existing_product)
            products[index] = updated_product
            save_product_to_db(updated_product)
            data_manager.products_changed.emit()

            self.update_product_table()
            QMessageBox.information(self, "成功", f"产品 {sku_cls} 已更新。")
        except Exception as e:
            print(f"更新产品时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"更新产品时发生错误：{e}")

    def delete_product(self):
        try:
            sku_cls = self.entries['SKU_CLS'].text().strip()
            if not sku_cls:
                QMessageBox.warning(self, "删除失败", "请输入 SKU CLS！")
                return

            product = get_product_by_sku(sku_cls)
            if product:
                # 从产品列表中删除
                products.remove(product)
                # 从数据库中删除
                delete_product_from_db(sku_cls)
                data_manager.products_changed.emit()

                self.update_product_table()
                QMessageBox.information(self, "成功", f"产品 {sku_cls} 已删除。")
            else:
                QMessageBox.information(self, "删除失败", f"未找到 SKU CLS 为 {sku_cls} 的产品。")
        except Exception as e:
            print(f"删除产品时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"删除产品时发生错误：{e}")
# order_details.py

import datetime
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QGridLayout, QComboBox, QFileDialog, QListWidget, QAbstractItemView, QListWidgetItem, QApplication
)
from PyQt6.QtGui import QShortcut, QKeySequence
from PyQt6.QtCore import Qt
import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import PatternFill

from data import (
    purchase_orders, deleted_orders, db_fields, delete_purchase_order_from_db,
    save_purchase_order_to_db, data_manager, update_inventory, inventory,
    update_inventory_arrival_date, get_purchase_order_by_nb, products, get_product_by_sku, save_product_to_db,
    load_products_from_db, delete_product_from_db
)
from price_calculator import open_price_calculator
import json
import datetime, re

class OrderDetailsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("采购订单管理")
        self.setGeometry(200, 200, 1400, 700)
        self.editing_in_progress = False
        self.layout_main = QVBoxLayout()

        # 输入区域
        self.layout_inputs = QGridLayout()
        self.layout_inputs.setHorizontalSpacing(10)
        self.entries = {}

        # 左侧字段
        left_fields = [
            ('订单号', 'Order Nb'),
            ('产品编号', 'Product_ID'),
            ('Order Type', 'Order Type'),
            ('Order Step', 'Order Step'),
            ('期望利润', "Expected Profit"),
            ('境内运费', 'Domestic Freight CAD'),
            ('国际运费', 'International Freight EURO'),
            ('EXW 汇率', 'EXW Exchange Rate'),
            ('国际运费汇率', 'International Freight Exchange Rate'),
            # 新增字段
            ("UCC14", "UCC14"),
            ("UCC13", "UCC13"),
        ]

        
        right_fields = [
            ("Supplier", "Supplier"),
            ("BCMB", "BCMB"),
            ("SKU CLS", "SKU CLS"),
            ("Supplier Order Number", "Supplier Order Number"),
            ("ITEM Name", "ITEM Name"),
            ("CATEGORY", "CATEGORY"),
            ("SIZE", "SIZE"),
            ("ALC.", "ALC."),
            ("QUANTITY CS", "QUANTITY CS"),
            ("BTL PER CS", "BTL PER CS"),
            ("EXW(€)", "EXW EURO"),
            ("REMARKS", "REMARKS"),
        ]

        # 左侧字段
        for row, (label_text, field_name) in enumerate(left_fields):
            label = QLabel(label_text + ":")
            label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            if field_name == "Order Type":
                entry = QComboBox()
                entry.addItems(["Allocation", "In Stock"])
                entry.setCurrentText("Allocation")
            elif field_name == "Order Step":
                entry = QComboBox()
                entry.addItems(["Offer", "Order", "Delivery"])
                entry.setCurrentText("Offer")
            elif field_name == "Expected Profit":
                entry = QLineEdit()
                entry.setText("0.05")
            elif field_name == "Domestic Freight CAD":
                entry = QLineEdit()
                entry.setText("35")
            elif field_name == "International Freight EURO":
                entry = QLineEdit()
                entry.setText("0")
            elif field_name == "EXW Exchange Rate":
                entry = QLineEdit()
                entry.setText("0")
            elif field_name == "International Freight Exchange Rate":
                entry = QLineEdit()
                entry.setText("0")
            else:
                entry = QLineEdit()
            entry.setFixedWidth(500)
            entry.setStyleSheet("border: 1px solid lightgray;")
            self.entries[field_name] = entry
            self.layout_inputs.addWidget(label, row, 0)
            self.layout_inputs.addWidget(entry, row, 1)

        for row, (label_text, field_name) in enumerate(right_fields):
            label = QLabel(label_text + ":")
            label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            if field_name == "Supplier":
                entry = QComboBox()
                entry.addItems(["Filips", "CVBG", "DULONG", "BONCHATEAU", "CDF"])
            elif field_name == "CATEGORY":
                entry = QComboBox()
                entry.addItems(["RED", "WHITE", "ROSE", "CHAMPAGNE"])
                entry.setCurrentText("RED")
            elif field_name == "SIZE":
                entry = QComboBox()
                entry.addItems(["0.75", "1.5", "3", "6", "9"])
                entry.setCurrentText("0.75")
            else:
                entry = QLineEdit()
            entry.setFixedWidth(500)
            entry.setStyleSheet("border: 1px solid lightgray;")
            self.entries[field_name] = entry
            self.layout_inputs.addWidget(label, row, 2)
            self.layout_inputs.addWidget(entry, row, 3)

        self.layout_main.addLayout(self.layout_inputs)

        # 按钮区域
        layout_buttons = QHBoxLayout()

        self.button_add = QPushButton("添加采购订单")
        self.button_add.clicked.connect(self.add_order)

        self.button_update = QPushButton("更新采购订单")
        self.button_update.clicked.connect(self.update_order)

        self.entry_search = QLineEdit()
        self.entry_search.setMaxLength(15)
        self.entry_search.setFixedWidth(100)
        button_search = QPushButton("查找订单")
        button_search.clicked.connect(self.find_order)

        self.entry_delete = QLineEdit()
        self.entry_delete.setMaxLength(30)
        self.entry_delete.setFixedWidth(100)
        button_delete = QPushButton("删除订单")
        button_delete.clicked.connect(self.delete_order)

        undo_button = QPushButton("撤销删除")
        undo_button.clicked.connect(self.undo_delete_order)

        button_export = QPushButton("导出订单")
        button_export.clicked.connect(self.export_orders)

        button_price_calculator = QPushButton("价格计算器")
        button_price_calculator.clicked.connect(lambda: self.open_price_calculator())

        button_compare = QPushButton("比较注册信息")
        button_compare.clicked.connect(self.compare_with_registration_file)

        layout_buttons.addWidget(self.button_add)
        layout_buttons.addWidget(self.button_update)
        layout_buttons.addWidget(button_search)
        layout_buttons.addWidget(self.entry_search)
        layout_buttons.addWidget(button_delete)
        layout_buttons.addWidget(self.entry_delete)
        layout_buttons.addWidget(undo_button)
        layout_buttons.addWidget(button_export)
        layout_buttons.addWidget(button_price_calculator)
        layout_buttons.addWidget(button_compare)

        self.layout_main.addLayout(layout_buttons)

        # 增加排序和过滤区域
        filter_sort_layout = QHBoxLayout()

        sort_label = QLabel("排序规则:")
        self.sort_combo = QComboBox()
        self.sort_combo.addItems(["按更新时间", "按订单号", "按Product_ID", "按SKU CLS", "按Supplier", "按ITEM Name", "按CATEGORY", "按INVOICE Price", "按WHOLESALE CS", "按EXW"])
        self.sort_combo.currentIndexChanged.connect(self.update_order_table)
        filter_sort_layout.addWidget(sort_label)
        filter_sort_layout.addWidget(self.sort_combo)

        filter_field_label = QLabel("过滤条件:")
        self.filter_field_combo = QComboBox()
        self.filter_field_combo.addItems(["按订单号", "按Supplier", "按ITEM Name", "按CATEGORY", "按Date", "按SKU CLS"])
        filter_sort_layout.addWidget(filter_field_label)
        filter_sort_layout.addWidget(self.filter_field_combo)

        self.filter_field_input = QLineEdit()
        self.filter_field_input.setPlaceholderText("输入过滤内容(支持*通配符)")
        self.filter_field_input.textChanged.connect(self.update_order_table)
        filter_sort_layout.addWidget(self.filter_field_input)

        self.layout_main.addLayout(filter_sort_layout)

        # 订单列表显示区域
        display_fields = [field for field in db_fields]
        self.order_table = QTableWidget()
        self.order_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectItems)
        self.order_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        # 将编辑触发模式设为双击或 F2 编辑，而非完全只读
        self.order_table.setEditTriggers(QTableWidget.EditTrigger.DoubleClicked | QTableWidget.EditTrigger.EditKeyPressed)
        self.order_table.setColumnCount(len(display_fields))
        self.order_table.setHorizontalHeaderLabels([label_text for label_text, field_name in display_fields])
        self.order_table.verticalHeader().setVisible(False)
        self.order_table.horizontalHeader().setStretchLastSection(True)
        self.order_table.setWordWrap(True)
        self.order_table.resizeColumnsToContents()
        # 连接订单表格的选择信号
        self.order_table.selectionModel().selectionChanged.connect(self.on_order_selected)
        # 连接编辑完成信号
        self.order_table.itemChanged.connect(self.on_item_changed)
        self.layout_main.addWidget(self.order_table)
        # 添加复制快捷键（Ctrl+C）和 ESC 快捷键取消选择
        self.copy_shortcut = QShortcut(QKeySequence(QKeySequence.StandardKey.Copy), self.order_table)
        self.copy_shortcut.activated.connect(self.copySelectedCells)
        self.clear_selection_shortcut = QShortcut(QKeySequence("Escape"), self.order_table)
        self.clear_selection_shortcut.activated.connect(lambda: self.order_table.clearSelection())
        self.setLayout(self.layout_main)
        self.update_order_table()

    def copySelectedCells(self):
        selected_ranges = self.order_table.selectedRanges()
        if not selected_ranges:
            return
        copied_text = ""
        for selection in selected_ranges:
            for row in range(selection.topRow(), selection.bottomRow() + 1):
                row_data = []
                for col in range(selection.leftColumn(), selection.rightColumn() + 1):
                    item = self.order_table.item(row, col)
                    row_data.append(item.text() if item else "")
                copied_text += "\t".join(row_data) + "\n"
        clipboard = QApplication.clipboard()
        clipboard.setText(copied_text)

    def get_filtered_and_sorted_purchase_orders(self):
        filtered_orders = purchase_orders.copy()

        filter_field = self.filter_field_combo.currentText()
        filter_value = self.filter_field_input.text().strip()

        if filter_value:
            pattern = None
            if '*' in filter_value:
                pattern = re.escape(filter_value).replace(r'\*', '.*')
                regex = re.compile(pattern, re.IGNORECASE)
            def match_field(val):
                if pattern:
                    return bool(regex.search(str(val)))
                else:
                    return filter_value.lower() in str(val).lower()

            if filter_field == "按订单号":
                filtered_orders = [o for o in filtered_orders if match_field(o.get('Order Nb',''))]
            elif filter_field == "按Supplier":
                filtered_orders = [o for o in filtered_orders if match_field(o.get('Supplier',''))]
            elif filter_field == "按ITEM Name":
                filtered_orders = [o for o in filtered_orders if match_field(o.get('ITEM Name',''))]
            elif filter_field == "按CATEGORY":
                filtered_orders = [o for o in filtered_orders if match_field(o.get('CATEGORY',''))]
            elif filter_field == "按Date":
                filtered_orders = [o for o in filtered_orders if match_field(o.get('date',''))]
            elif filter_field == "按SKU CLS":
                filtered_orders = [o for o in filtered_orders if match_field(o.get('SKU CLS',''))]

        sort_option = self.sort_combo.currentText()
        def sort_key(order):
            if sort_option == "按更新时间":
                return order.get('date', '')
            elif sort_option == "按订单号":
                return order.get('Order Nb','')
            elif sort_option == "按Product_ID":
                return order.get('Product_ID','')
            elif sort_option == "按SKU CLS":
                return order.get('SKU CLS','')
            elif sort_option == "按Supplier":
                return order.get('Supplier','')
            elif sort_option == "按ITEM Name":
                return order.get('ITEM Name','')
            elif sort_option == "按CATEGORY":
                return order.get('CATEGORY','')
            elif sort_option == "按INVOICE Price":
                try:
                    return float(order.get('INVOICE PRICE',0))
                except:
                    return 0
            elif sort_option == "按WHOLESALE CS":
                try:
                    return float(order.get('WHOLESALE CS',0))
                except:
                    return 0
            elif sort_option == "按EXW":
                try:
                    return float(order.get('EXW EURO',0))
                except:
                    return 0
            return ''

        filtered_orders = sorted(filtered_orders, key=sort_key)
        return filtered_orders

    def on_order_selected(self, selected, deselected):
        try:
            indexes = self.order_table.selectionModel().selectedIndexes()
            if indexes:
                row = indexes[0].row()  # 取第一个选中单元格所在的行
                fs_orders = self.get_filtered_and_sorted_purchase_orders()
                order = fs_orders[row]
                for field_name, entry in self.entries.items():
                    value = order.get(field_name, "")
                    if isinstance(entry, QComboBox):
                        combo_index = entry.findText(str(value))
                        if combo_index >= 0:
                            entry.setCurrentIndex(combo_index)
                        else:
                            entry.setCurrentText(str(value))
                    else:
                        entry.setText(str(value))
            else:
                for entry in self.entries.values():
                    if isinstance(entry, QComboBox):
                        entry.setCurrentIndex(-1)
                    else:
                        entry.clear()
        except Exception as e:
            print(f"处理订单选择时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"处理订单选择时发生错误：{e}")

    def add_order(self):
        try:
            new_order = {}
            for field_name, entry in self.entries.items():
                if isinstance(entry, QComboBox):
                    value = entry.currentText().strip()
                else:
                    value = entry.text().strip()

                # 数据校验逻辑调整：SKU CLS 应为字符串，不进行整数转换
                # QUANTITY CS 和 BTL PER CS 为整数字段
                # ITEM Name 必填
                # 其他浮点字段进行浮点验证


                if field_name in ["QUANTITY CS", "BTL PER CS", "SKU CLS"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = int(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的整数！")
                        return

                elif field_name == "ITEM Name":
                    if not value:
                        QMessageBox.warning(self, "输入错误", "ITEM Name 不能为空！")
                        return

                elif field_name in ["ALC.", "EXW EURO", "Expected Profit", "Domestic Freight CAD", "International Freight EURO", "EXW Exchange Rate", "International Freight Exchange Rate"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = float(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的数字！")
                        return

                new_order[field_name] = value

            # 添加日期
            new_order['date'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # 基本检查
            if not new_order['Order Nb']:
                QMessageBox.warning(self, "添加失败", "订单号不能为空！")
                return

            product_id = new_order.get('Product_ID', '')
            if not product_id:
                QMessageBox.warning(self, "添加失败", "产品编号不能为空！")
                return

            if any(order['Order Nb'] == new_order['Order Nb'] for order in purchase_orders):
                QMessageBox.warning(self, "添加失败", "该订单号已存在！")
                return

            # 在添加订单前，先检查 SKU CLS 对应的产品是否存在
            sku_cls = str(new_order.get('SKU CLS', '')).strip()
            product = get_product_by_sku(sku_cls)
            if not product:
                # 产品不存在，尝试添加产品
                if not self.attempt_add_product_to_management(new_order):
                    # 添加产品失败，直接返回
                    return
                else:
                    # 产品添加成功或者已存在了，现在继续添加订单
                    pass

            # 此时产品已存在，可以继续更新库存和保存订单
            quantity_cs = int(new_order.get('QUANTITY CS', 0))
            btl_per_cs = int(new_order.get('BTL PER CS', 0))
            arrival_date = new_order.get('Arrival_Date', '')
            creation_date = new_order.get('date', '')
            item_name = new_order.get('ITEM Name', '')
            sku_cls = str(new_order.get('SKU CLS', '')).strip()

            update_inventory(
                product_id,
                new_order['Order Nb'],
                quantity_cs,
                arrival_date,
                creation_date,
                item_name,
                sku_cls,
                btl_per_cs,
                operation_type='add_purchase_order'
            )

            purchase_orders.append(new_order)
            save_purchase_order_to_db(new_order)
            data_manager.data_changed.emit()

            self.update_order_table()
            QMessageBox.information(self, "成功", f"订单 {new_order['Order Nb']} 已添加。")

        except Exception as e:
            print(f"添加订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"添加订单时发生错误：{e}")

    def attempt_add_product_to_management(self, order_data):
        """尝试将订单中的产品信息添加到产品列表中（product management）。
           如果添加成功返回 True，失败返回 False。"""
        try:
            # 从订单中获取产品必需信息
            sku_cls = str(order_data.get('SKU CLS', '')).strip()
            item_name = str(order_data.get('ITEM Name', '')).strip()
            category = str(order_data.get('CATEGORY', '')).strip()
            size_str = str(order_data.get('SIZE', '')).strip()
            alc_str = str(order_data.get('ALC.', '')).strip()
            btl_per_cs_str = str(order_data.get('BTL PER CS', '')).strip()
            supplier = str(order_data.get('Supplier', '')).strip()

            # 检查必填字段
            if not sku_cls or not item_name or not category or not size_str or not alc_str or not btl_per_cs_str or not supplier:
                QMessageBox.warning(self, "添加产品失败", "产品信息不完整，无法添加到产品列表中。")
                return False

            # 转换数据类型
            try:
                size = float(size_str)
                alc = float(alc_str)
                btl_per_cs = int(btl_per_cs_str)
            except ValueError:
                QMessageBox.warning(self, "添加产品失败", "Size、ALC、BTL PER CS 必须是有效的数字！")
                return False

            # 检查 SKU_CLS 是否已存在
            if get_product_by_sku(sku_cls) is not None:
                # 已存在，无需重复添加
                return True

            new_product = {
                'SKU_CLS': sku_cls,
                'ITEM_Name': item_name,
                'Category': category,
                'Size': size,
                'ALC': alc,
                'BTL_PER_CS': btl_per_cs,
                'Supplier': supplier,
                'Creation_Date': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }

            save_product_to_db(new_product)

            # 刷新产品列表
            load_products_from_db()

            # 确认添加成功
            if get_product_by_sku(sku_cls) is not None:
                QMessageBox.information(self, "提示", f"产品 {sku_cls} 已成功添加到产品列表中。")
                return True
            else:
                QMessageBox.warning(self, "添加产品失败", "无法在产品列表中找到新添加的产品，请检查数据。")
                return False

        except Exception as e:
            print(f"尝试添加产品到产品管理时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"添加产品到产品列表时发生错误：{e}")
            return False

    def update_order(self):
        try:
            order_nb = self.entries['Order Nb'].text().strip()
            if not order_nb:
                QMessageBox.warning(self, "更新失败", "请输入订单号！")
                return

            # 获取现有订单数据
            existing_order = get_purchase_order_by_nb(order_nb)
            if not existing_order:
                QMessageBox.warning(self, "更新失败", "订单号不存在！")
                return

            # 准备更新后的订单数据
            updated_order = {}
            for field_name, entry in self.entries.items():
                if isinstance(entry, QComboBox):
                    value = entry.currentText().strip()
                else:
                    value = entry.text().strip()

                # 处理需要整数的字段
                if field_name in ["QUANTITY CS", "BTL PER CS", "SKU CLS"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = int(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的整数！")
                        return
               
                elif field_name in ["ITEM Name"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                
                # 处理需要浮点数的字段
                elif field_name in ["ALC.", "EXW EURO", "Expected Profit", "Domestic Freight CAD", "EXW EURO", "International Freight EURO", "EXW Exchange Rate", "International Freight Exchange Rate"]:
                    if not value:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 不能为空！")
                        return
                    try:
                        value = float(value)
                    except ValueError:
                        QMessageBox.warning(self, "输入错误", f"{field_name} 必须是一个有效的数字！")
                        return

                updated_order[field_name] = value

            # 更新日期
            updated_order['date'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
             # —— 1. 判断 SKU CLS 是否有变化 ——
            old_sku_cls = str(existing_order.get('SKU CLS', '')).strip()
            new_sku_cls = str(updated_order.get('SKU CLS', '')).strip()
            
            sku_changed = (old_sku_cls != new_sku_cls)

            # —— 2. 如果 SKU CLS 发生变化，先检查/添加新的 SKU CLS 到 products 表 ——
            if sku_changed:
                # 如果新的 SKU_CLS 不在产品表中，则自动添加
                product_in_new_sku = get_product_by_sku(new_sku_cls)
                if not product_in_new_sku:
                    # 这里复用已有的添加逻辑，比如 attempt_add_product_to_management
                    if not self.attempt_add_product_to_management(updated_order):
                        # 如果添加失败，可直接中断更新流程
                        return
            # 计算数量差异
            old_quantity_cs = int(existing_order.get('QUANTITY CS', 0))
            new_quantity_cs = int(updated_order.get('QUANTITY CS', 0))
            delta_quantity_cs = new_quantity_cs - old_quantity_cs

            old_btl_per_cs = int(existing_order.get('BTL PER CS', 0))
            new_btl_per_cs = int(updated_order.get('BTL PER CS', 0))
            old_quantity_btl = old_quantity_cs * old_btl_per_cs
            new_quantity_btl = new_quantity_cs * new_btl_per_cs
            delta_quantity_btl = new_quantity_btl - old_quantity_btl

            # 更新库存数量
            product_id = updated_order.get('Product_ID', '')
            arrival_date = updated_order.get('Arrival_Date', '')
            creation_date = updated_order.get('date', '')
            item_name = updated_order.get('ITEM Name', '')
            sku_cls = updated_order.get('SKU CLS', '')
            btl_per_cs = updated_order.get('BTL PER CS', 0)

            update_inventory(
                product_id,
                order_nb,
                delta_quantity_cs,
                arrival_date,
                creation_date,
                item_name,
                sku_cls,
                btl_per_cs,
                operation_type='update_purchase_order'
            )

            # 保存更新后的订单
            index = purchase_orders.index(existing_order)
            purchase_orders[index] = updated_order
            save_purchase_order_to_db(updated_order)
            data_manager.data_changed.emit()
             # —— 5. 如果 SKU CLS 被改掉了，则尝试删除旧的 SKU CLS 的产品记录 ——
            if sku_changed:
                self.check_and_remove_unused_product(old_sku_cls)
            # 更新库存中的 Arrival_Date
            update_inventory_arrival_date(product_id, order_nb, arrival_date)

            self.update_order_table()
            QMessageBox.information(self, "成功", f"订单 {order_nb} 已更新。")
        except Exception as e:
            print(f"更新订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"更新订单时发生错误：{e}")
    
    def check_and_remove_unused_product(self, sku_cls: str):
        """
        判断 products 表中某个 sku_cls 是否还被任何采购订单使用，
        如果没有使用，就把它删除掉。
        """
        try:
            if not sku_cls:
                return
            product = get_product_by_sku(sku_cls)
            if not product:
                return
            # 在 purchase_orders 搜索是否还有其他订单的 SKU CLS == 这个值
            is_used = any(
                (str(o.get('SKU CLS', '')).strip() == sku_cls)
                for o in purchase_orders
            )
            if not is_used:
                # 说明没有别的采购订单在用它，可以安全删除
                delete_product_from_db(sku_cls)
                # 同步从内存的 products 中删除
                product_to_remove = next((p for p in products if p['SKU_CLS'] == sku_cls), None)
                if product_to_remove:
                    products.remove(product_to_remove)
                data_manager.products_changed.emit()
                QMessageBox.information(None, "自动删除旧产品", f"已自动删除旧 SKU_CLS={sku_cls} 对应的产品记录，因为它已不再使用。")
            else:
                QMessageBox.information(None, "旧产品仍然存在", f"请注意！ 旧产品 SKU_CLS={sku_cls} 仍有对应的产品存在。")
        except Exception as e:
            print(f"check_and_remove_unused_product 时发生错误: {e}")
    
    def open_price_calculator(self):
        open_price_calculator(self)

    def find_order(self):
        try:
            search_order_nb = self.entry_search.text().strip()
            if not search_order_nb:
                QMessageBox.warning(self, "查找失败", "请输入要查找的订单号！")
                return
            order = get_purchase_order_by_nb(search_order_nb)
            if order:
                # 在表格中定位并选中该订单
                for row in range(self.order_table.rowCount()):
                    if self.order_table.item(row, 0).text() == search_order_nb:
                        self.order_table.selectRow(row)
                        # 滚动到该行
                        self.order_table.scrollToItem(self.order_table.item(row, 0))
                        break
            else:
                QMessageBox.information(self, "查找结果", f"未找到订单号为 {search_order_nb} 的订单。")
        except Exception as e:
            print(f"查找订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"查找订单时发生错误：{e}")


    def delete_order(self):
        try:
            order_nb = self.entry_delete.text().strip()
            if not order_nb:
                QMessageBox.warning(self, "删除失败", "请输入要删除的订单号！")
                return
            order = get_purchase_order_by_nb(order_nb)
            
            # 调试输出
            print(f"Order data: {order}")
            print(f"Order type: {type(order)}")

            if order:
                # 从采购订单列表中删除
                purchase_orders.remove(order)
                # 添加到已删除订单列表，用于撤销删除
                deleted_orders.append(order)
                # 从数据库中删除
                delete_purchase_order_from_db(order_nb)
                data_manager.data_changed.emit()  # 发射数据变化信号
                # 获取当前库存
                quantity_cs = int(order.get('QUANTITY CS', 0))
                btl_per_cs = int(order.get('BTL PER CS', 0))

                # 减少库存
                update_inventory(
                    order.get('Product_ID', ''),
                    order_nb,
                    -quantity_cs,
                    order.get('Arrival_Date', ''),
                    order.get('date', ''),
                    order.get('ITEM Name', ''),
                    order.get('SKU CLS', ''),
                    btl_per_cs,
                    operation_type='revoke_purchase_order'
                )
                print(f"成功执行update_inventory函数")
                self.update_order_table()
                QMessageBox.information(self, "成功", f"订单 {order_nb} 已删除。")
            else:
                QMessageBox.information(self, "删除失败", f"未找到订单号为 {order_nb} 的订单。")
        except Exception as e:
            print(f"删除订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"删除订单时发生错误：{e}")


    def undo_delete_order(self):
        try:
            if not deleted_orders:
                QMessageBox.information(self, "撤销删除", "没有可撤销的删除操作。")
                return
            # 取出最后一个被删除的订单
            order = deleted_orders.pop()
            # 添加回采购订单列表
            purchase_orders.append(order)
            # 保存到数据库
            save_purchase_order_to_db(order)
            data_manager.data_changed.emit()  # 发射数据变化信号
            # 更新库存
            quantity_cs = int(order.get('QUANTITY CS', 0))
            btl_per_cs = int(order.get('BTL PER CS', 0))
            quantity_btl = quantity_cs * btl_per_cs
            # 增加库存
            update_inventory(
                order.get('Product_ID', ''),
                order['Order Nb'],
                quantity_cs,
                order.get('Arrival_Date', ''),
                order.get('date', ''),
                order.get('ITEM Name', ''),
                order.get('SKU CLS', ''),
                btl_per_cs,
                operation_type='add_purchase_order' #删除订单就会从库存中删除，所以撤销删除订单对库存来说等于新添加
            )
            self.update_order_table()
            QMessageBox.information(self, "成功", f"订单 {order['Order Nb']} 已恢复。")
        except Exception as e:
            print(f"撤销删除时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"撤销删除时发生错误：{e}")


    def export_orders(self):
        try:
            # 获取当前显示的订单(过滤+排序后的列表)
            filtered_sorted_orders = self.get_filtered_and_sorted_purchase_orders()

            if len(filtered_sorted_orders) == 0:
                QMessageBox.information(self, "导出", "没有可导出的订单数据。")
                return

            import pandas as pd
            df = pd.DataFrame(filtered_sorted_orders)

            # 指定导出字段顺序(与原先代码保持一致)
            field_order = [field_name for label_text, field_name in db_fields if field_name in df.columns]
            df = df[field_order]

            # 删除 "PROFIT PER BT" 字段（如果存在）
            if "PROFIT PER BT" in df.columns:
                df.drop("PROFIT PER BT", axis=1, inplace=True, errors='ignore')

            # 尝试将可转为数值的列转为数值类型
            # 这样在输出Excel时，这些列会是数字格式（而非纯文本）
            for col in df.columns:
                try:
                    # 尝试将列转为数值类型，如果失败将触发异常
                    df[col] = pd.to_numeric(df[col])
                except ValueError:
                    # 转换失败表示该列并非纯数字列，保持原样即可，不进行处理
                    pass

            # 弹出文件保存对话框
            from PyQt6.QtWidgets import QFileDialog
            options = QFileDialog.Option.DontUseNativeDialog
            file_name, _ = QFileDialog.getSaveFileName(self, "保存文件", "", "Excel Files (*.xlsx);;All Files (*)", options=options)

            if file_name:
                if not file_name.endswith('.xlsx'):
                    file_name += '.xlsx'
                df.to_excel(file_name, index=False)
                QMessageBox.information(self, "导出成功", f"采购订单已导出到文件 {file_name}")
        except Exception as e:
            print(f"导出订单时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"导出订单时发生错误：{e}")


    def update_order_table(self):
        """
        更新订单表格显示，根据过滤排序后的订单列表更新各单元格，
        并针对价格计算相关字段设置为可编辑，其它字段设置为只读。
        """
        display_fields = [field for field in db_fields]
        filtered_sorted_orders = self.get_filtered_and_sorted_purchase_orders()

        # 在更新前屏蔽 itemChanged 信号，防止内部修改触发信号
        self.order_table.blockSignals(True)
        self.order_table.setRowCount(0)
        self.order_table.setRowCount(len(filtered_sorted_orders))

        # 定义哪些字段允许手动编辑
        editable_fields = {"INVOICE PRICE", "INVOICE CS", "WHOLESALE BTL", "WHOLESALE CS",
                           "TOTAL Freight", "PROFIT PER BT", "PROFIT PER CS", "PROFIT TOTAL",
                           "QUANTITY BTL", "TOTAL AMOUNT", "TOTAL AMOUNT EURO", "REMARKS"}

        for row, order in enumerate(filtered_sorted_orders):
            for col, (label_text, field_name) in enumerate(display_fields):
                value = order.get(field_name, "")
                item = QTableWidgetItem(str(value))
                # 如果该字段在 editable_fields 中，则允许编辑，否则设置只读
                if field_name in editable_fields:
                    item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
                else:
                    item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)
                self.order_table.setItem(row, col, item)
        self.order_table.blockSignals(False)

    def on_item_changed(self, item):
        """
        当用户修改订单表格中某个单元格后，更新对应订单的数据，并保存到数据库。
        为避免内部更新引发递归调用，使用 editing_in_progress 标志。
        """
        if self.editing_in_progress:
            return

        try:
            self.editing_in_progress = True
            col = item.column()
            # 根据 display_fields 获取字段名
            display_fields = [field for field in db_fields]
            field_name = display_fields[col][1]  # display_fields 元素为 (label_text, field_name)
            # 只对可编辑字段进行处理
            editable_fields = {"INVOICE PRICE", "INVOICE CS", "WHOLESALE BTL", "WHOLESALE CS",
                               "TOTAL Freight", "PROFIT PER BT", "PROFIT PER CS", "PROFIT TOTAL",
                               "QUANTITY BTL", "TOTAL AMOUNT", "TOTAL AMOUNT EURO", "REMARKS"}
            if field_name not in editable_fields:
                return

            # 获取当前修改所在的行
            row = item.row()
            # 获取当前显示的订单列表（经过过滤排序后的列表）
            filtered_sorted_orders = self.get_filtered_and_sorted_purchase_orders()
            if row >= len(filtered_sorted_orders):
                return

            # 修改对应订单中的字段
            order = filtered_sorted_orders[row]
            new_value = item.text().strip()
            order[field_name] = new_value
            # 调用保存到数据库的函数（更新时可直接调用 save_purchase_order_to_db）
            save_purchase_order_to_db(order)
            # 若需要，可以发射数据变化信号刷新界面
            data_manager.data_changed.emit()
        except Exception as e:
            print(f"更新订单单元格时发生错误：{e}")
        finally:
            self.editing_in_progress = False

    def showEvent(self, event):
        super().showEvent(event)
        self.update_order_table()

    def compare_with_registration_file(self):
        try:
            # 获取选定的采购订单
            selected_rows = self.order_table.selectionModel().selectedRows()
            if not selected_rows:
                QMessageBox.warning(self, "提示", "请先选择要比较的采购订单（可多选）。")
                return

            fs_orders = self.get_filtered_and_sorted_purchase_orders()
            selected_orders = []
            for index in selected_rows:
                row = index.row()
                order = fs_orders[row]
                selected_orders.append(order)
            for idx, order in enumerate(selected_orders):
                print(f"第 {idx} 条订单：{order}")


            # 让用户选择注册文件（Excel 格式）
            options = QFileDialog.Option.DontUseNativeDialog
            file_name, _ = QFileDialog.getOpenFileName(
                self, "选择注册文件", "", "Excel Files (*.xlsx);;All Files (*)", options=options)

            if not file_name:
                return

            # 读取注册文件
            registration_df = pd.read_excel(file_name)

            # 将列名统一转换为小写
            registration_df.columns = registration_df.columns.str.lower()

            # 打印列名调试
            #print("读取的注册文件列名：", registration_df.columns.tolist())

            # 确保 'sku cls' 字段存在
            if 'sku cls' not in registration_df.columns:
                QMessageBox.warning(self, "错误", "注册文件中缺少 'SKU CLS' 列。")
                return

            # 将 SKU CLS 转为字符串并统一为小写，便于匹配
            registration_df['sku cls'] = registration_df['sku cls'].astype(str).str.strip().str.lower()

            # 创建一个字典，存储采购订单中的信息，键为 SKU CLS（统一转换为小写）
            po_data = {}
            for order in selected_orders:
                sku_cls = str(order.get('SKU CLS', '')).strip().lower()  # 转换为小写
                po_data[sku_cls] = {
                    'category_po': order.get('CATEGORY', ''),
                    'size_po': order.get('SIZE', ''),
                    'alc_po': order.get('ALC.', ''),
                    'btl per cs_po': order.get('BTL PER CS', ''),
                    'wholesale cs_po': order.get('WHOLESALE CS', ''),
                    'supplier_po': order.get('Supplier', ''),
                    'item name_po': order.get('ITEM Name', ''),
                    'invoice cs_po': order.get('INVOICE CS', '')
                }


                # 打印 po_data
                #print("采购订单数据 po_data：", json.dumps(po_data, indent=2, ensure_ascii=False))


            # 需要比较的字段（统一小写以匹配列名）
            fields_to_compare = ['category', 'size', 'alc', 'btl per cs', 'wholesale cs', 'supplier', 'item name', 'invoice cs' ]

            # 在 DataFrame 中插入采购订单的信息
            for field in fields_to_compare:
                po_field = f"{field}_po"
                # 如果原始注册文件中没有对应的列，跳过
                if field not in registration_df.columns:
                    QMessageBox.warning(self, "错误", f"注册文件中缺少 '{field}' 列。")
                    return
                # 在对应的列右侧插入新列
                col_index = registration_df.columns.get_loc(field) + 1
                registration_df.insert(col_index, po_field, "")

            # 遍历注册文件，填入采购订单的信息并比较
            for idx, row in registration_df.iterrows():
                sku_cls = str(row.get('sku cls', '')).strip().lower()  # 转换为小写
                #print(f"注册文件 SKU CLS: {sku_cls}")
                if sku_cls in po_data:
                    #print(f"匹配到的采购订单信息: {po_data[sku_cls]}")
                    for field in fields_to_compare:
                        po_field = f"{field}_po"
                        po_value = po_data[sku_cls].get(f"{field}_PO", '')  # 从 po_data 获取值
                        #print(f"填入 {field}_PO 的值: {po_value}")
                        registration_df.at[idx, po_field] = po_data[sku_cls].get(f"{field}_po", '')
                else:
                    print(f"未匹配到采购订单信息: {sku_cls}")

            # 保存修改后的 DataFrame 到临时 Excel 文件，以便使用 openpyxl 进行样式处理
            temp_file = 'temp_registration.xlsx'
            registration_df.to_excel(temp_file, index=False)

            # 使用 openpyxl 打开临时文件，处理样式
            wb = load_workbook(temp_file)
            ws = wb.active

            # 定义高亮样式RFA
            fill = PatternFill(start_color='FFFF00', end_color='FFFF00', fill_type='solid')

            # 比较并高亮不一致的单元格
            for idx, row in registration_df.iterrows():
                excel_row = idx + 2  # DataFrame 的索引从 0 开始，Excel 的行从 1 开始，且有标题行
                sku_cls = str(row.get('sku cls', '')).strip().lower()  # 转换为小写
                if sku_cls in po_data:
                    for field in fields_to_compare:
                        po_field = f"{field}_po"
                        reg_value = str(row.get(field, '')).strip()
                        po_value = str(row.get(po_field, '')).strip()
                        if reg_value != po_value:
                            # 高亮注册文件的原始值
                            col_index_reg = registration_df.columns.get_loc(field) + 1  # DataFrame 列索引从 0 开始
                            cell_reg = ws.cell(row=excel_row, column=col_index_reg)
                            cell_reg.fill = fill
                            # 高亮采购订单的值
                            col_index_po = registration_df.columns.get_loc(po_field) + 1
                            cell_po = ws.cell(row=excel_row, column=col_index_po)
                            cell_po.fill = fill

            # 让用户选择保存文件的位置
            save_file_name, _ = QFileDialog.getSaveFileName(
                self, "保存比较结果", "", "Excel Files (*.xlsx);;All Files (*)", options=options)



            #print("注册文件列名：", registration_df.columns.tolist())
            #print("插入后的列名：", registration_df.columns.tolist())


            if not save_file_name:
                return

            if not save_file_name.endswith('.xlsx'):
                save_file_name += '.xlsx'

            # 保存处理后的工作簿
            wb.save(save_file_name)

            # 删除临时文件
            import os
            os.remove(temp_file)

            QMessageBox.information(self, "成功", f"比较完成，结果已保存到 {save_file_name}")

        except Exception as e:
            print(f"比较时发生错误：{e}")
            QMessageBox.critical(self, "错误", f"比较时发生错误：{e}")
# main.py
import os
import shutil
import datetime
from PyQt6.QtWidgets import (
    QApplication, QWidget, QPushButton, QVBoxLayout, QHBoxLayout, QMessageBox
)
import sys
import file_compare
from data import (
    initialize_database,
    load_purchase_orders_from_db,
    load_sales_orders_from_db,
    load_inventory_from_db,
    load_products_from_db
)
from order_details import OrderDetailsWindow
from inventory_management import InventoryManagementWindow
from sales_order import SalesOrderWindow
from product_management import ProductManagementWindow  
from financial_management import FinancialManagementWindow

# 配置数据库和备份文件夹路径
DB_PATH = r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db'
BACKUP_FOLDER = r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\backups'
COUNTER_FILE = os.path.join(BACKUP_FOLDER, 'backup_counter.txt')
def backup_database(backup_type):
    if not os.path.exists(BACKUP_FOLDER):
        os.makedirs(BACKUP_FOLDER)
    
    # 使用当天日期作为时间戳，确保一天内备份文件名固定
    date_stamp = datetime.datetime.now().strftime('%Y%m%d')
    if backup_type == "auto":
        backup_file = os.path.join(BACKUP_FOLDER, f"orders_backup_auto_{date_stamp}.db")
    elif backup_type == "periodic":
        backup_file = os.path.join(BACKUP_FOLDER, f"orders_backup_periodic_{date_stamp}.db")
    else:
        backup_file = os.path.join(BACKUP_FOLDER, f"orders_backup_{backup_type}_{date_stamp}.db")
    
    try:
        shutil.copy2(DB_PATH, backup_file)
        print(f"[{backup_type}备份成功] 数据库已备份至：{backup_file}")
    except Exception as e:
        print(f"[{backup_type}备份失败] 无法备份数据库：{e}")

def update_backup_counter():
    """
    更新备份计数器，每次启动程序调用此函数。
    如果计数器文件不存在，则创建并初始化为 1；否则累加 1 并写回文件。
    返回当前计数值。
    """
    # 如果备份目录不存在，则创建
    if not os.path.exists(BACKUP_FOLDER):
        os.makedirs(BACKUP_FOLDER)
        
    count = 0
    if os.path.exists(COUNTER_FILE):
        try:
            with open(COUNTER_FILE, 'r', encoding='utf-8') as f:
                count = int(f.read().strip())
        except Exception as e:
            print(f"[计数器读取错误] {e}")
    count += 1  # 每次启动时加 1
    try:
        with open(COUNTER_FILE, 'w', encoding='utf-8') as f:
            f.write(str(count))
    except Exception as e:
        print(f"[计数器写入错误] {e}")
    return count

def perform_backup_on_startup():
    """
    在程序启动时执行两个备份：
    1. 每次启动均做自动备份（类型：auto）。
    2. 每打开五次程序时，再做一次周期备份（类型：periodic）。
    """
    # 自动备份
    backup_database("auto")
    # 更新计数器，并判断是否达到周期条件
    count = update_backup_counter()
    print(f"[启动计数] 当前启动次数：{count}")
    if count % 5 == 0:
        backup_database("periodic")

perform_backup_on_startup()
# 创建主窗口
app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("订单管理系统")
window.setGeometry(100, 100, 800, 600)

# 程序启动时加载数据
initialize_database()
load_purchase_orders_from_db()
load_sales_orders_from_db()
load_inventory_from_db()
load_products_from_db()  # 新增

# 布局设置
layout_main = QVBoxLayout()

# 按钮区域
layout_buttons = QHBoxLayout()

button_order_details = QPushButton("采购订单管理")
button_order_details.clicked.connect(lambda: open_order_details_window())

button_sales_order = QPushButton("销售订单管理")
button_sales_order.clicked.connect(lambda: open_sales_order_window())

button_inventory_management = QPushButton("库存管理")
button_inventory_management.clicked.connect(lambda: open_inventory_management_window())

button_product_management = QPushButton("产品管理")  
button_product_management.clicked.connect(lambda: open_product_management_window())  

button_file_compare_tool = QPushButton("文件对比工具")
button_file_compare_tool.clicked.connect(lambda: file_compare.open_file_compare_tool())

button_financial_management = QPushButton("财务管理")
button_financial_management.clicked.connect(lambda: open_financial_management_window())

layout_buttons.addWidget(button_order_details)
layout_buttons.addWidget(button_sales_order)
layout_buttons.addWidget(button_inventory_management)
layout_buttons.addWidget(button_product_management)
layout_buttons.addWidget(button_file_compare_tool)
layout_buttons.addWidget(button_financial_management)

layout_main.addLayout(layout_buttons)


# 定义窗口实例
order_details_window = None
sales_order_window = None
inventory_management_window = None
product_management_window = None  
financial_management_window = None

# 打开采购订单窗口
def open_order_details_window():
    global order_details_window
    try:
        if order_details_window is None:
            order_details_window = OrderDetailsWindow()
        else:
            order_details_window.update_order_table()
        order_details_window.show()
    except Exception as e:
        print(f"打开采购订单窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开采购订单窗口时发生错误：{e}")

# 打开销售订单窗口
def open_sales_order_window():
    global sales_order_window
    try:
        if sales_order_window is None:
            sales_order_window = SalesOrderWindow()
        else:
            sales_order_window.update_sales_order_table()
        sales_order_window.show()
    except Exception as e:
        print(f"打开销售订单窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开销售订单窗口时发生错误：{e}")

# 打开库存管理窗口
def open_inventory_management_window():
    global inventory_management_window
    try:
        if inventory_management_window is None:
            inventory_management_window = InventoryManagementWindow()
        else:
            inventory_management_window.update_inventory_tables()
        inventory_management_window.show()
    except Exception as e:
        print(f"打开库存管理窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开库存管理窗口时发生错误：{e}")

# 打开产品管理窗口
def open_product_management_window():
    global product_management_window
    try:
        if product_management_window is None:
            product_management_window = ProductManagementWindow()
        else:
            product_management_window.update_product_table()
        product_management_window.show()
    except Exception as e:
        print(f"打开产品管理窗口时发生错误：{e}")
        QMessageBox.critical(None, "错误", f"打开产品管理窗口时发生错误：{e}")

def open_financial_management_window():
    global financial_management_window
    try:
        if financial_management_window is None:
            financial_management_window = FinancialManagementWindow()
        else:
            financial_management_window.calculate_financial_metrics()
        financial_management_window.show()
    except Exception as e:
        QMessageBox.critical(None, "错误", f"打开财务管理窗口时发生错误：{e}")

# 设置主布局
window.setLayout(layout_main)
window.show()

if __name__ == "__main__":
    sys.exit(app.exec())
# inventory_management.py

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QLabel,
    QLineEdit, QHBoxLayout, QPushButton, QFormLayout, QComboBox,
    QHeaderView, QMessageBox, QAbstractItemView, QApplication, QHeaderView
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QShortcut, QKeySequence
from data import inventory, load_inventory_from_db, data_manager, save_inventory_to_db, purchase_orders, get_purchase_order_by_nb
import datetime
import re
from dateutil.parser import parse

class InventoryManagementWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("库存管理")
        self.setGeometry(300, 300, 1000, 600)

        self.layout_main = QVBoxLayout()

        # 输入区域
        self.layout_inputs = QFormLayout()
        self.entries = {}

        # 调整间距
        self.layout_inputs.setSpacing(5)
        self.layout_inputs.setContentsMargins(0, 0, 0, 0)

        # 修改后的“到货日期”输入项
        label_arrival_date = QLabel("到货日期:")
        self.entry_arrival_date = QLineEdit()
        self.entry_arrival_date.setPlaceholderText("YYYY-MM-DD")
        self.entries['Arrival_Date'] = self.entry_arrival_date
        self.layout_inputs.addRow(label_arrival_date, self.entry_arrival_date)
        self.entry_arrival_date.setFixedWidth(120)

        # 新增的“提货日期”输入项
        label_pickup_date = QLabel("提货日期:")
        self.entry_pickup_date = QLineEdit()
        self.entry_pickup_date.setPlaceholderText("YYYY-MM-DD")
        self.entries['Pick_up_Date'] = self.entry_pickup_date
        self.layout_inputs.addRow(label_pickup_date, self.entry_pickup_date)
        self.entry_pickup_date.setFixedWidth(120)

        # 更新按钮
        self.button_update = QPushButton("更新")
        self.button_update.clicked.connect(self.update_inventory_record)
        # 将“更新”按钮添加到新的行
        button_layout = QHBoxLayout()
        button_layout.addStretch(1)
        button_layout.addWidget(self.button_update)
        button_layout.addStretch(1)
        self.layout_inputs.addRow(button_layout)

        self.layout_main.addLayout(self.layout_inputs)

        # 明细标题和过滤选项
        detail_layout = QHBoxLayout()

        # 添加排序和过滤控件的布局
        control_layout = QHBoxLayout()

        # 添加排序选项
        sort_label = QLabel("排序规则:")
        self.sort_combo = QComboBox()
        self.sort_combo.addItems(["按更新时间", "按采购订单号", "按销售订单", "按产品编号", "按库存-箱数"])
        self.sort_combo.currentIndexChanged.connect(self.update_inventory_tables)
        sort_layout = QHBoxLayout()
        sort_layout.addWidget(sort_label)
        sort_layout.addWidget(self.sort_combo)
        sort_layout.setSpacing(5)
        sort_layout.setContentsMargins(0, 0, 0, 0)
        control_layout.addLayout(sort_layout)

        # 添加过滤选项
        filter_field_label = QLabel("过滤条件:")
        self.filter_field_combo = QComboBox()
        self.filter_field_combo.addItems(["按产品编号", "按采购订单", "按Order Type", "按SKU CLS", "按产品名称"])
        self.filter_field_combo.currentIndexChanged.connect(self.update_inventory_tables)
        self.filter_field_input = QLineEdit()
        self.filter_field_input.setPlaceholderText("输入过滤内容")
        self.filter_field_input.textChanged.connect(self.update_inventory_tables)
        self.filter_field_input.setFixedWidth(150)
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(filter_field_label)
        filter_layout.addWidget(self.filter_field_combo)
        filter_layout.addWidget(self.filter_field_input)
        filter_layout.setSpacing(5)
        filter_layout.setContentsMargins(0, 0, 0, 0)
        control_layout.addLayout(filter_layout)

        # 添加弹性空间，将控件靠左对齐
        control_layout.addStretch(1)

        # 添加“库存明细”标签并使其居中
        title_layout = QHBoxLayout()
        title_layout.addStretch(1)
        detail_label = QLabel("库存明细")
        detail_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_layout.addWidget(detail_label)
        title_layout.addStretch(1)

        # 将控件布局和标题布局添加到 detail_layout
        detail_layout.addLayout(control_layout)
        detail_layout.addLayout(title_layout)

        self.layout_main.addLayout(detail_layout)

        # 明细库存列表
        self.detail_inventory_table = QTableWidget()
        self.detail_inventory_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectItems)
        self.detail_inventory_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.detail_inventory_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.detail_inventory_table.setColumnCount(14)
        self.detail_inventory_table.setHorizontalHeaderLabels([
            'Order Type', '采购订单', '销售订单', '产品编号', 'SKU CLS', '产品名称',
            '库存-箱数', '总瓶数', '采购总数', '库存天数', '到货日期', '提货日期', '售空日期', '创建日期'
        ])
        self.detail_inventory_table.verticalHeader().setVisible(False)
        # 修改列宽调整模式
        header = self.detail_inventory_table.horizontalHeader()
        for i in range(self.detail_inventory_table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.Interactive)

        self.layout_main.addWidget(self.detail_inventory_table)
        #添加复制快捷键（如有需要）
        self.copy_shortcut = QShortcut(QKeySequence(QKeySequence.StandardKey.Copy), self.detail_inventory_table)
        self.copy_shortcut.activated.connect(self.copySelectedCells)
        
        # 添加 ESC 快捷键：按下 ESC 后清除表格中所有选中单元格
        self.clear_selection_shortcut = QShortcut(QKeySequence("Escape"), self.detail_inventory_table)
        self.clear_selection_shortcut.activated.connect(lambda: self.detail_inventory_table.clearSelection())

        # 总览标题
        total_label = QLabel("库存总览")
        total_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout_main.addWidget(total_label)

        # 总览库存列表
        self.total_inventory_table = QTableWidget()
        self.total_inventory_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.total_inventory_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.total_inventory_table.setColumnCount(8)
        self.total_inventory_table.setHorizontalHeaderLabels(['产品编号', '采购订单', '销售订单', 'SKU CLS', '产品名称', '库存-箱数','库存-总瓶数', '采购-总瓶数'])
        self.total_inventory_table.verticalHeader().setVisible(False)
        # 列可拖拽大小
        total_header = self.total_inventory_table.horizontalHeader()
        for i in range(self.total_inventory_table.columnCount()):
            total_header.setSectionResizeMode(i, QHeaderView.ResizeMode.Interactive)

        self.layout_main.addWidget(self.total_inventory_table)

        self.setLayout(self.layout_main)

        # 初始化变量
        self.selected_inventory_item = None

        # 连接选择信号到处理函数
        self.detail_inventory_table.selectionModel().selectionChanged.connect(self.on_order_selected)
        # 连接数据变化信号到更新方法
        data_manager.inventory_changed.connect(self.on_inventory_changed)
        
        # 加载库存数据
        load_inventory_from_db()
        self.update_inventory_tables()

    def on_inventory_changed(self):
        self.update_inventory_tables()

    def copySelectedCells(self):
        selected_ranges = self.detail_inventory_table.selectedRanges()
        if not selected_ranges:
            return
        copied_text = ""
        for selection in selected_ranges:
            for row in range(selection.topRow(), selection.bottomRow() + 1):
                row_data = []
                for col in range(selection.leftColumn(), selection.rightColumn() + 1):
                    item = self.detail_inventory_table.item(row, col)
                    row_data.append(item.text() if item else "")
                copied_text += "\t".join(row_data) + "\n"
        clipboard = QApplication.clipboard()
        clipboard.setText(copied_text)

    def on_order_selected(self, selected, deselected):
        indexes = self.detail_inventory_table.selectionModel().selectedIndexes()
        if indexes:
            row = indexes[0].row()
            product_id = self.detail_inventory_table.item(row, 3).text()  # 产品编号所在列
            order_nb = self.detail_inventory_table.item(row, 1).text()    # 采购订单号所在列
            inventory_item = next((item for item in inventory if item['Product_ID'] == product_id and item['Order_Nb'] == order_nb), None)
            if inventory_item:
                self.selected_inventory_item = inventory_item
                self.entry_arrival_date.setText(inventory_item.get('Arrival_Date', ''))
                self.entry_pickup_date.setText(inventory_item.get('Pick_up_Date', ''))
            else:
                self.selected_inventory_item = None
                self.entry_arrival_date.clear()
                self.entry_pickup_date.clear()
        else:
            self.selected_inventory_item = None
            self.entry_arrival_date.clear()
            self.entry_pickup_date.clear()


    def update_inventory_record(self):
        if not self.selected_inventory_item:
            QMessageBox.warning(self, "更新错误", "请先选择要更新的库存记录！")
            return
        # 获取输入的日期
        arrival_date_str = self.entry_arrival_date.text().strip()
        pickup_date_str = self.entry_pickup_date.text().strip()
        # 创建一个标志，检查是否有更新
        has_update = False
        # 验证并更新到货日期
        if arrival_date_str:
            try:
                datetime.datetime.strptime(arrival_date_str, '%Y-%m-%d')
                self.selected_inventory_item['Arrival_Date'] = arrival_date_str
                has_update = True
            except ValueError:
                QMessageBox.warning(self, "输入错误", "到货日期格式错误，请输入YYYY-MM-DD")
                return
        if pickup_date_str:
            try:
                datetime.datetime.strptime(pickup_date_str, '%Y-%m-%d')
                self.selected_inventory_item['Pick_up_Date'] = pickup_date_str
                has_update = True
            except ValueError:
                QMessageBox.warning(self, "输入错误", "提货日期格式错误，请输入YYYY-MM-DD")
                return
        if has_update:
            inventory_item_to_save = self.selected_inventory_item.copy()
            inventory_item_to_save.pop('Order_Type', None)
            save_inventory_to_db(inventory_item_to_save)
            QMessageBox.information(self, "成功", "库存记录已更新。")
            self.update_inventory_tables()
        else:
            QMessageBox.warning(self, "更新错误", "没有可更新的日期。")

    def update_inventory_tables(self):
        # 获取排序和过滤条件
        sort_option = self.sort_combo.currentText()
        filter_field = self.filter_field_combo.currentText()
        filter_value = self.filter_field_input.text().strip()

        filtered_inventory = inventory.copy()

        # 过滤
        if filter_value:
            pattern = None
            if '*' in filter_value:
                pattern = re.escape(filter_value).replace(r'\*', '.*')
                regex = re.compile(pattern, re.IGNORECASE)
            def match_field(val):
                if pattern:
                    return bool(regex.search(str(val)))
                else:
                    return filter_value.lower() in str(val).lower()

            if filter_field == "按产品编号":
                filtered_inventory = [item for item in filtered_inventory if match_field(item.get('Product_ID',''))]
            elif filter_field == "按采购订单":
                filtered_inventory = [item for item in filtered_inventory if match_field(item.get('Order_Nb',''))]
            elif filter_field == "按Order Type":
                filtered_inventory = [item for item in filtered_inventory if match_field(item.get('Order_Type',''))]
            elif filter_field == "按SKU CLS":
                filtered_inventory = [item for item in filtered_inventory if match_field(item.get('SKU_CLS',''))]
            elif filter_field == "按产品名称":
                filtered_inventory = [item for item in filtered_inventory if match_field(item.get('Product_Name',''))]

        # 排序
        def sort_key(x):
            if sort_option == "按更新时间":
                return x.get('Last_Update','')
            elif sort_option == "按采购订单号":
                return x.get('Order_Nb','')
            elif sort_option == "按销售订单":
                return x.get('Sales_Orders','')
            elif sort_option == "按产品编号":
                return x.get('Product_ID','')
            elif sort_option == "按库存-箱数":
                return int(x.get('Current_Stock_CS',0))
            return ''

        reverse = True if sort_option in ["按更新时间","按库存-箱数"] else False
        # 更新时间和库存-箱数按照需要可选是否逆序，这里保持和之前逻辑一致（更新时间原本就是reverse=True）
        if sort_option == "按更新时间":
            # 原代码是reverse = True
            sorted_inventory = sorted(filtered_inventory, key=sort_key, reverse=True)
        elif sort_option == "按库存-箱数":
            # 原来是reverse=True
            sorted_inventory = sorted(filtered_inventory, key=sort_key, reverse=True)
        else:
            sorted_inventory = sorted(filtered_inventory, key=sort_key, reverse=False)

        # 更新明细表
        self.detail_inventory_table.setRowCount(0)
        self.detail_inventory_table.setRowCount(len(sorted_inventory))

        # 建立订单号到销售订单映射
        order_nb_to_sales_orders = {}
        for item in sorted_inventory:
            order_nb = item['Order_Nb']
            sales_order = item.get('Sales_Orders', '')
            if order_nb not in order_nb_to_sales_orders:
                order_nb_to_sales_orders[order_nb] = set()
            if sales_order:
                order_nb_to_sales_orders[order_nb].update([s.strip() for s in sales_order.split(',')])

        for row, product in enumerate(sorted_inventory):
            self.detail_inventory_table.setItem(row, 0, QTableWidgetItem(product.get('Order_Type', '')))
            self.detail_inventory_table.setItem(row, 1, QTableWidgetItem(product['Order_Nb']))
            sales_orders = order_nb_to_sales_orders.get(product['Order_Nb'], set())
            sales_order_str = ', '.join(sorted(sales_orders))
            self.detail_inventory_table.setItem(row, 2, QTableWidgetItem(sales_order_str))
            self.detail_inventory_table.setItem(row, 3, QTableWidgetItem(product['Product_ID']))
            self.detail_inventory_table.setItem(row, 4, QTableWidgetItem(product.get('SKU_CLS', '')))
            self.detail_inventory_table.setItem(row, 5, QTableWidgetItem(product['Product_Name']))
            self.detail_inventory_table.setItem(row, 6, QTableWidgetItem(str(product['Current_Stock_CS'])))
            btl_per_cs = int(product.get('BTL PER CS', 0))
            total_btl = int(product['Current_Stock_CS']) * btl_per_cs
            self.detail_inventory_table.setItem(row, 7, QTableWidgetItem(str(total_btl)))

            # 采购总数：对应采购订单的 QUANTITY CS * BTL PER CS
            purchase_order = get_purchase_order_by_nb(product['Order_Nb'])
            if purchase_order:
                po_qty_cs = int(purchase_order.get('QUANTITY CS', 0))
                po_btl_per_cs = int(purchase_order.get('BTL PER CS', 0))
                purchase_total_btl = po_qty_cs * po_btl_per_cs
            else:
                purchase_total_btl = 0
            self.detail_inventory_table.setItem(row, 8, QTableWidgetItem(str(purchase_total_btl)))

            arrival_date_str = product.get('Arrival_Date', '')
            pickup_date_str = product.get('Pick_up_Date', '')
            if arrival_date_str:
                arrival_date = parse(arrival_date_str)
                if pickup_date_str:
                    pickup_date = parse(pickup_date_str)
                    delta_days = (pickup_date - arrival_date).days
                else:
                    delta_days = (datetime.datetime.now() - arrival_date).days
                self.detail_inventory_table.setItem(row, 9, QTableWidgetItem(str(delta_days)))
            else:
                self.detail_inventory_table.setItem(row, 9, QTableWidgetItem("N/A"))

            self.detail_inventory_table.setItem(row, 10, QTableWidgetItem(product.get('Arrival_Date', '')))
            self.detail_inventory_table.setItem(row, 11, QTableWidgetItem(product.get('Pick_up_Date', '')))
            self.detail_inventory_table.setItem(row, 12, QTableWidgetItem(product.get('Sale_Date', '')))
            self.detail_inventory_table.setItem(row, 13, QTableWidgetItem(product.get('Creation_Date', '')))

        # 更新总览表
        total_inventory = {}
        for product in sorted_inventory:
            product_id = product['Product_ID']
            # 使用小写形式作为键
            product_key = product_id.lower()
            order_nb = product.get('Order_Nb', '')
            sales_order = product.get('Sales_Orders', '')
            sku_cls = product.get('SKU_CLS', '')
            product_name = product['Product_Name']
            current_stock_cs = int(product['Current_Stock_CS'])
            btl_per_cs = int(product.get('BTL PER CS', 0))
            current_stock_btl = current_stock_cs * btl_per_cs

            if product_key not in total_inventory:
                total_inventory[product_key] = {
                    'Product_ID': product_id,  # 保留首次遇到的原始格式用于显示
                    'Order_Nb_Set': set([order_nb]),
                    'Sales_Order_Set': set(),
                    'SKU_CLS': sku_cls,
                    'Product_Name': product_name,
                    'Current_Stock_CS': current_stock_cs,
                    'Current_Stock_BTL': current_stock_btl
                }
            else:
                total_inventory[product_key]['Order_Nb_Set'].add(order_nb)
                total_inventory[product_key]['Current_Stock_CS'] += current_stock_cs
                total_inventory[product_key]['Current_Stock_BTL'] += current_stock_btl

            if sales_order:
                total_inventory[product_key]['Sales_Order_Set'].update([s.strip() for s in sales_order.split(',')])

        total_inventory_list = list(total_inventory.values())

        # 总览表排序规则同样应用
        # 重用 sort_option 根据需要
        def total_sort_key(x):
            if sort_option == "按更新时间":
                # 无直接更新时间，暂不排序
                return ''
            elif sort_option == "按采购订单号":
                return ','.join(sorted(x['Order_Nb_Set']))
            elif sort_option == "按销售订单":
                return ','.join(sorted(x['Sales_Order_Set']))
            elif sort_option == "按产品编号":
                return x.get('Product_ID','')
            elif sort_option == "按库存-箱数":
                return x.get('Current_Stock_CS',0)
            return ''

        if sort_option in ["按库存-箱数"]:
            total_inventory_list = sorted(total_inventory_list, key=total_sort_key, reverse=True)
        else:
            total_inventory_list = sorted(total_inventory_list, key=total_sort_key)

        self.total_inventory_table.setRowCount(0)
        self.total_inventory_table.setRowCount(len(total_inventory_list))
        for row, product in enumerate(total_inventory_list):
            self.total_inventory_table.setItem(row, 0, QTableWidgetItem(product['Product_ID']))
            order_nb_str = ', '.join(sorted(product['Order_Nb_Set']))
            self.total_inventory_table.setItem(row, 1, QTableWidgetItem(order_nb_str))
            sales_order_str = ', '.join(sorted(product['Sales_Order_Set']))
            self.total_inventory_table.setItem(row, 2, QTableWidgetItem(sales_order_str))
            self.total_inventory_table.setItem(row, 3, QTableWidgetItem(product.get('SKU_CLS', '')))
            self.total_inventory_table.setItem(row, 4, QTableWidgetItem(product['Product_Name']))
            self.total_inventory_table.setItem(row, 5, QTableWidgetItem(str(product['Current_Stock_CS'])))
            self.total_inventory_table.setItem(row, 6, QTableWidgetItem(str(product['Current_Stock_BTL'])))

            # 采购-总瓶数计算
            product_id = product['Product_ID']
            purchase_total_btl_sum = 0
            for po in purchase_orders:
                if po.get('Product_ID', '') == product_id:
                    qcs = int(po.get('QUANTITY CS', 0))
                    bpcs = int(po.get('BTL PER CS', 0))
                    purchase_total_btl_sum += qcs * bpcs
            self.total_inventory_table.setItem(row, 7, QTableWidgetItem(str(purchase_total_btl_sum)))
# data.py
import sqlite3
import datetime
import json
from PyQt6.QtWidgets import QMessageBox
from PyQt6.QtCore import QObject, pyqtSignal

# 定义共享数据
purchase_orders = []
sales_orders = []
inventory = []
deleted_orders = []
products = []
db_fields = [
    ("订单号", "Order Nb"),
    ("Product_ID", "Product_ID"),
    ("Order Type", "Order Type"),
    ("Order Step", "Order Step"),
    ("期望利润", "Expected Profit"),
    ("境内运费(CAD)", "Domestic Freight CAD"),
    ("EXW汇率", "EXW Exchange Rate"),
    ("国际运费(€)", "International Freight EURO"),
    ("国际运费汇率", "International Freight Exchange Rate"),
    ("TOTAL Freight", "TOTAL Freight"),
    ("Supplier", "Supplier"),
    ("BCMB", "BCMB"),
    ("SKU CLS", "SKU CLS"),
    ("供应商发票号", "Supplier Order Number"),
    ("ITEM Name", "ITEM Name"),
    ("CATEGORY", "CATEGORY"),
    ("SIZE", "SIZE"),
    ("ALC.", "ALC."),
    ("QUANTITY CS", "QUANTITY CS"),
    ("BTL PER CS", "BTL PER CS"),
    ("QUANTITY BTL", "QUANTITY BTL"),
    ("EXW(€)", "EXW EURO"),
    ("TOTAL AMOUNT(€)", "TOTAL AMOUNT EURO"),
    ("REMARKS", "REMARKS"),
    ("WHOLESALE BTL", "WHOLESALE BTL"),
    ("WHOLESALE CS", "WHOLESALE CS"),
    ("PROFIT PER BT", "PROFIT PER BT"),
    ("PROFIT PER CS", "PROFIT PER CS"),
    ("PROFIT TOTAL", "PROFIT TOTAL"),
    ("INVOICE PRICE", "INVOICE PRICE"),
    ("INVOICE CS", "INVOICE CS"),
    ("Date", "date"),
    ("UCC14", "UCC14"),
    ("UCC13", "UCC13"),
]

# 数据管理器，用于发射数据变化信号
class DataManager(QObject):
    data_changed = pyqtSignal()
    inventory_changed = pyqtSignal()
    products_changed = pyqtSignal()
    def __init__(self):
        super().__init__()

data_manager = DataManager()

# 初始化数据库
def initialize_database():
    conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
    cursor = conn.cursor()

    # 创建采购订单表
    field_definitions = ', '.join([f'"{field[1]}" TEXT' for field in db_fields if field[1] != 'Order Nb'])
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS purchase_orders (
            "Order Nb" TEXT PRIMARY KEY,
            {field_definitions}
        )
    ''')

    # 创建销售订单表
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS sales_orders (
            "Sales_ID" TEXT PRIMARY KEY,
            "Product_ID" TEXT,
            "Customer_ID" TEXT,
            "Quantity_CS_Sold" INTEGER,
            "Quantity_BTL_Sold" INTEGER,
            "Total_Quantity_BTL_Sold" INTEGER,
            "Price_per_bottle" REAL,
            "Total_Amount" REAL,
            "Order_Date" TEXT,
            "Shipped_Date" TEXT,
            "Remarks" TEXT,
            "Deduction_Details" TEXT,
            "Order_Nb" TEXT,
            "Product_Name",
            "BTL_PER_CS" INTEGER
        )
    ''')

    # 创建库存表
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS inventory (
            "Product_ID" TEXT,
            "Order_Nb" TEXT,
            "Product_Name" TEXT,
            "SKU_CLS" TEXT,
            "Current_Stock_CS" INTEGER,
            "BTL PER CS" INTEGER,
            "Last_Update" TEXT,
            "Arrival_Date" TEXT,
            "Creation_Date" TEXT,
            "Sale_Date" TEXT,
            "Sales_Orders" TEXT,
            "Pick_up_Date" TEXT,
            PRIMARY KEY ("Product_ID", "Order_Nb")
        )
    ''')
    #创建产品表
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS products (
            "SKU_CLS" TEXT PRIMARY KEY,
            "ITEM_Name" TEXT,
            "Category" TEXT,
            "Size" REAL,
            "ALC" REAL,
            "BTL_PER_CS" INTEGER,
            "Supplier" TEXT,
            "Creation_Date" TEXT
        )
    ''')
    conn.commit()
    conn.close()

# 加载采购订单
def load_purchase_orders_from_db():
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM purchase_orders')
        rows = cursor.fetchall()
        conn.close()

        purchase_orders.clear()
        reversed_rows = rows[::-1]
        for row in reversed_rows:
            order = {}
            for idx, field in enumerate(cursor.description):
                field_name = field[0]
                order[field_name] = row[idx] if row[idx] is not None else ''
            purchase_orders.append(order)
    except Exception as e:
        print(f"无法从数据库加载采购订单数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载采购订单数据：{e}")

# 保存采购订单
def save_purchase_order_to_db(order):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        placeholders = ', '.join(['?' for _ in order.keys()])
        field_names = ', '.join([f'"{key}"' for key in order.keys()])
        values = list(order.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO purchase_orders ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存采购订单时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存采购订单时发生错误：{e}")

# 删除采购订单
def delete_purchase_order_from_db(order_nb):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        cursor.execute('DELETE FROM purchase_orders WHERE "Order Nb" = ?', (order_nb,))
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"删除采购订单时发生错误：{e}")
        QMessageBox.critical(None, "删除错误", f"删除采购订单时发生错误：{e}")

# 加载销售订单
def load_sales_orders_from_db():
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM sales_orders')
        rows = cursor.fetchall()
        conn.close()

        sales_orders.clear()
        reversed_rows = rows[::-1]
        for row in reversed_rows:
            order = {}
            for idx, field in enumerate(cursor.description):
                field_name = field[0]
                if field_name == 'Deduction_Details':
                    order[field_name] = json.loads(row[idx]) if row[idx] else []
                else:
                    order[field_name] = row[idx] if row[idx] is not None else ''
            sales_orders.append(order)
    except Exception as e:
        print(f"无法从数据库加载销售订单数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载销售订单数据：{e}")

# 保存销售订单
def save_sales_order_to_db(order):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()

        # 序列化 Deduction_Details
        deduction_details_json = json.dumps(order.get('Deduction_Details', []))
        # 创建一个副本用于保存，不修改原始 order 对象
        order_to_save = order.copy()
        order_to_save['Deduction_Details'] = deduction_details_json

        placeholders = ', '.join(['?' for _ in order_to_save.keys()])
        field_names = ', '.join([f'"{key}"' for key in order_to_save.keys()])
        values = list(order_to_save.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO sales_orders ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存销售订单时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存销售订单时发生错误：{e}")


# 删除销售订单
def delete_sales_order_from_db(sales_id):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        cursor.execute('DELETE FROM sales_orders WHERE "Sales_ID" = ?', (sales_id,))
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"删除销售订单时发生错误：{e}")
        QMessageBox.critical(None, "删除错误", f"删除销售订单时发生错误：{e}")

# 加载库存数据
def load_inventory_from_db():
    try:
        global inventory
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM inventory')
        rows = cursor.fetchall()
        conn.close()

        inventory.clear()
        for row in rows:
            product = dict(row)
            # 从采购订单中获取对应的 Order Type
            order_nb = product.get('Order_Nb', '')
            purchase_order = get_purchase_order_by_nb(order_nb)
            product['Order_Type'] = purchase_order.get('Order Type', '') if purchase_order else ''
            inventory.append(product)
    except Exception as e:
        print(f"无法从数据库加载库存数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载库存数据：{e}")

# 保存库存数据
def save_inventory_to_db(product):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        placeholders = ', '.join(['?' for _ in product.keys()])
        field_names = ', '.join([f'"{key}"' for key in product.keys()])
        values = list(product.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO inventory ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存库存数据时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存库存数据时发生错误：{e}")

# 更新库存数量
def update_inventory(product_id, order_nb, quantity_change_cs, arrival_date, creation_date, item_name, sku_cls, btl_per_cs, operation_type, sale_date=None, sales_orders=None, operation_subtype=None, Pick_up_Date=None ):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        
        # 查询当前库存
        cursor.execute('SELECT "Current_Stock_CS", "BTL PER CS", "Sales_Orders" FROM inventory WHERE "Product_ID" = ? AND "Order_Nb" = ?', (product_id, order_nb))
        result = cursor.fetchone()
        if result:
            # 如果库存记录存在，更新库存数量
            current_stock_cs = int(result[0])
            #current_btl_per_cs = int(result[1])
            new_stock_cs = current_stock_cs + quantity_change_cs

            if new_stock_cs < 0: #or new_stock_btl < 0:
                raise ValueError("库存不足，无法减少库存")
            
            # 获取当前 Sales_Orders
            existing_sales_orders = set(result[2].split(',')) if result[2] else set()
            if operation_subtype == 'remove_sales_order':
                # 移除指定值
                remove_sales_orders = set(sales_orders.split(',')) if sales_orders else set()
                updated_sales_orders = existing_sales_orders - remove_sales_orders
                updated_sales_orders_str = ','.join(sorted(updated_sales_orders))
            else:
                new_sales_orders = set(sales_orders.split(',')) if sales_orders else set()
                updated_sales_orders_str = ','.join(sorted(existing_sales_orders.union(new_sales_orders)))
            print(f"operation_subtype: {operation_subtype}")
            # 更新库存
            if new_stock_cs == 0: #and new_stock_btl == 0:
                if operation_type == 'revoke_purchase_order':
                    # 撤销采购订单导致库存为零，删除库存记录
                    cursor.execute('DELETE FROM inventory WHERE "Product_ID" = ? AND "Order_Nb" = ?', (product_id, order_nb))
                else:
                    # 正常销售导致库存为零，保留库存记录
                    cursor.execute('UPDATE inventory SET "Product_ID" = ?, "Order_Nb" = ?, "Product_Name" = ?, "SKU_CLS" = ?, "Current_Stock_CS" = 0, "BTL PER CS" = ?, "Last_Update" = ?, "Arrival_Date" = ?, "Creation_Date" = ?, "Sale_Date" = ?, "Sales_Orders" = ? WHERE "Product_ID" = ? AND "Order_Nb" = ?',
                                   (product_id, order_nb, item_name, sku_cls, btl_per_cs, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), arrival_date, creation_date, sale_date or datetime.datetime.now().strftime("%Y-%m-%d"), updated_sales_orders_str, product_id, order_nb))
            else:
                # 库存数量不为零，更新库存记录
                cursor.execute('UPDATE inventory SET "Product_ID" = ?, "Order_Nb" = ?, "Product_Name" = ?, "SKU_CLS" = ?, "Current_Stock_CS" = ?, "BTL PER CS" = ?, "Last_Update" = ?, "Arrival_Date" = ?, "Creation_Date" = ?, "Sale_Date" = NULL, "Sales_Orders" = ? WHERE "Product_ID" = ? AND "Order_Nb" = ?',
                               (product_id, order_nb, item_name, sku_cls, new_stock_cs, btl_per_cs, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), arrival_date, creation_date, updated_sales_orders_str, product_id, order_nb))

        else:
            # 库存记录不存在
            if quantity_change_cs > 0:#or quantity_change_btl > 0:
                # 增加库存，新增库存记录
                cursor.execute('INSERT INTO inventory ("Product_ID", "Order_Nb", "Product_Name", "SKU_CLS", "Current_Stock_CS", "BTL PER CS", "Last_Update", "Arrival_Date", "Creation_Date") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
                               (product_id, order_nb, item_name, sku_cls, quantity_change_cs, btl_per_cs, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), arrival_date, creation_date))
            else:
                # 减少库存，且库存记录不存在，抛出异常
                raise ValueError("库存中不存在该产品，无法减少库存")

        conn.commit()
        conn.close()

        # 更新内存中的 inventory 列表
        load_inventory_from_db()
        # 发射 inventory_changed 信号
        data_manager.inventory_changed.emit()

    except Exception as e:
        print(f"更新库存时发生错误：{e}")
        raise e

# 获取库存记录
def get_inventory_item(product_id, order_nb):
    for item in inventory:
        if item['Product_ID'] == product_id and item['Order_Nb'] == order_nb:
            return item
    return None
#获取产品信息
def get_inventory_info(product_id, order_nb):
    for item in inventory:
        if item['Product_ID'] == product_id and item['Order_Nb'] == order_nb:
            return item.get('Product_Name', ''), int(item.get('BTL PER CS', 0))
    return '', 0

# 更新库存中的 Arrival_Date
def update_inventory_arrival_date(product_id, order_nb, arrival_date):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        cursor.execute('UPDATE inventory SET "Arrival_Date" = ? WHERE "Product_ID" = ? AND "Order_Nb" = ?', (arrival_date, product_id, order_nb))
        conn.commit()
        conn.close()

        # 更新内存中的 inventory 列表
        load_inventory_from_db()
        data_manager.inventory_changed.emit()
    except Exception as e:
        print(f"更新库存 Arrival_Date 时发生错误：{e}")
        raise e

# 恢复库存（用于删除销售订单）
def restore_inventory(sales_order):
    try:
        # 从销售订单中获取扣减详情
        deduction_details = sales_order.get('Deduction_Details', [])
        if not deduction_details:
            raise ValueError("销售订单中缺少扣减详情，无法恢复库存")

        for deduction in deduction_details:
            # 确保 deduction 是一个字典
            if not isinstance(deduction, dict):
                raise ValueError(f"扣减详情格式错误：{deduction}")

            product_id = sales_order['Product_ID']
            order_nb = deduction['Order_Nb']
            add_cs = deduction['Deduct_CS']

            # 获取库存记录的信息
            inventory_item = get_inventory_item(product_id, order_nb)
            if not inventory_item:
                raise ValueError(f"无法找到库存记录，产品ID: {product_id}, 订单号: {order_nb}")

            btl_per_cs = int(inventory_item.get('BTL PER CS', 0))
            current_stock_cs = int(inventory_item.get('Current_Stock_CS', 0))
            arrival_date = inventory_item.get('Arrival_Date')
            creation_date = inventory_item.get('Creation_Date')
            product_name = inventory_item.get('Product_Name')
            sku_cls = inventory_item.get('SKU_CLS')
            # 计算新的瓶数和箱数
            new_stock_cs = current_stock_cs + add_cs
            '''# 获取现有的 Sales_Orders
            existing_sales_orders = inventory_item.get('Sales_Orders', '')
            if existing_sales_orders:
                # 将字符串转换为集合
                existing_sales_orders_set = set(existing_sales_orders.split(','))
                # 从集合中移除当前销售订单号
                updated_sales_orders_set = existing_sales_orders_set - {sales_order['Sales_ID']}
                # 转换回字符串
                updated_sales_orders = ','.join(sorted(updated_sales_orders_set))
            else:
                updated_sales_orders = None'''
            # 更新库存
            update_inventory(
                product_id,
                order_nb,
                new_stock_cs - current_stock_cs,
                arrival_date,
                creation_date,
                product_name,
                sku_cls,
                btl_per_cs,
                operation_type='restore_sales',
                sales_orders = sales_order['Sales_ID'],
                operation_subtype = 'remove_sales_order'
            )

    except Exception as e:
        print(f"恢复库存时发生错误：{e}")
        raise e


# 根据订单号获取采购订单
def get_purchase_order_by_nb(order_nb):
    return next((order for order in purchase_orders if order['Order Nb'] == order_nb), None)

# 根据 Product_ID 获取采购订单
def get_purchase_order_by_product_id(product_id):
    for order in purchase_orders:
        if order['Product_ID'] == product_id:
            return order
    return None

# 获取 BTL_PER_CS
def get_btl_per_cs(product_id):
    order = get_purchase_order_by_product_id(product_id)
    if order:
        return int(order.get('BTL PER CS', 0))
    else:
        return 0

# 获取 WHOLESALE BTL
def get_WHOLESALE_BTL_price(product_id):
    order = get_purchase_order_by_product_id(product_id)
    if order:
        wholesale_btl = order.get('WHOLESALE BTL', 0)
        # 检查 wholesale_btl 是否为字符串，如果不是，转换为字符串
        if not isinstance(wholesale_btl, str):
            wholesale_btl = str(wholesale_btl)
        # 检查是否为空字符串或无法转换成浮点数
        if wholesale_btl.strip() == '':
            wholesale_btl = '0'  # 如果为空字符串，将其设置为 '0'
        try:
            return float(wholesale_btl)
        except ValueError:
            # 处理转换错误，返回默认值或抛出更具体的错误
            print(f"Invalid value for WHOLESALE BTL: {wholesale_btl}")
            return 0.0  # 返回默认值
        #print(f"获取到的WHOLESALE BTL 为：{wholesale_btl}")
    else:
        return 0.0

# 加载产品数据
def load_products_from_db():
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM products')
        rows = cursor.fetchall()
        conn.close()

        products.clear()
        for row in rows:
            product = {}
            for idx, field in enumerate(cursor.description):
                field_name = field[0]
                product[field_name] = row[idx] if row[idx] is not None else ''
            products.append(product)
    except Exception as e:
        print(f"无法从数据库加载产品数据：{e}")
        QMessageBox.critical(None, "加载错误", f"无法从数据库加载产品数据：{e}")

# 保存产品
def save_product_to_db(product):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        placeholders = ', '.join(['?' for _ in product.keys()])
        field_names = ', '.join([f'"{key}"' for key in product.keys()])
        values = list(product.values())

        cursor.execute(f'''
            INSERT OR REPLACE INTO products ({field_names})
            VALUES ({placeholders})
        ''', values)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"保存产品时发生错误：{e}")
        QMessageBox.critical(None, "保存错误", f"保存产品时发生错误：{e}")

# 删除产品
def delete_product_from_db(sku_cls):
    try:
        conn = sqlite3.connect(r'D:\00_Programming\98_Pycharm\00_Workplace\Order Manager\Official_Tool\01_Cursor_Code\01_Working\00_Main Branch\orders.db')
        cursor = conn.cursor()
        cursor.execute('DELETE FROM products WHERE "SKU_CLS" = ?', (sku_cls,))
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"删除产品时发生错误：{e}")
        QMessageBox.critical(None, "删除错误", f"删除产品时发生错误：{e}")

# 根据 SKU_CLS 获取产品
def get_product_by_sku(sku_cls):
    return next((product for product in products if product['SKU_CLS'] == sku_cls), None)

# 在采购订单添加时检查并添加新产品
def check_and_add_new_product(order):
    sku_cls = str(order.get('SKU CLS', '')).strip()
    product = get_product_by_sku(sku_cls)
    if not product:
        # 产品不存在，自动添加到产品列表
        new_product = {
            'SKU_CLS': sku_cls,
            'ITEM_Name': order.get('ITEM Name', ''),
            'Category': order.get('CATEGORY', ''),
            'Size': float(order.get('SIZE', 0)),
            'ALC': float(order.get('ALC.', 0)),
            'BTL_PER_CS': int(order.get('BTL PER CS', 0)),
            'Supplier': order.get('Supplier', ''),
            'Creation_Date': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        products.append(new_product)
        save_product_to_db(new_product)
        data_manager.products_changed.emit()
        QMessageBox.information(None, "新产品添加", f"产品 {sku_cls} 为新产品，已自动添加到产品列表中。")
    else:
        # 产品已存在，验证信息一致性
        inconsistencies = []
        fields_to_check = ['ITEM_Name', 'Category', 'Size', 'ALC', 'BTL_PER_CS', 'Supplier']
        for field in fields_to_check:
            order_field = order.get(field.replace('_', ' '), '')
            product_field = product.get(field, '')
            if str(order_field).strip() != str(product_field).strip():
                print(f"order_field{order_field}")
                print(f"order_field{product_field}")
                inconsistencies.append(field)
        if inconsistencies:
            QMessageBox.warning(None, "产品信息不一致", f"产品 {sku_cls} 的以下信息与产品列表不一致：{', '.join(inconsistencies)}。请检查。")

def cascade_update_purchase_order(old_order_nb, new_order_nb, new_order_data=None):
    """
    将采购订单号从 old_order_nb 更新为 new_order_nb，并级联更新所有相关记录。
    参数:
      old_order_nb: 旧的采购订单号
      new_order_nb: 新的采购订单号
      new_order_data: 其他需要同时更新的字段（可选）
    """
    # 1. 更新采购订单数据（内存中和数据库）
    for order in purchase_orders:
        if order.get("Order Nb") == old_order_nb:
            order["Order Nb"] = new_order_nb
            if new_order_data:
                order.update(new_order_data)
            save_purchase_order_to_db(order)
            break

    # 2. 级联更新销售订单中的引用
    for s_order in sales_orders:
        # 如果销售订单的主订单号字段等于旧订单号，更新为新订单号
        if s_order.get("Order_Nb", "") == old_order_nb:
            s_order["Order_Nb"] = new_order_nb
        # 更新销售订单中扣减详情里引用的订单号
        for deduction in s_order.get("Deduction_Details", []):
            if deduction.get("Order_Nb") == old_order_nb:
                deduction["Order_Nb"] = new_order_nb
        save_sales_order_to_db(s_order)
    
    # 3. 级联更新库存记录中的订单号
    for item in inventory:
        if item.get("Order_Nb", "") == old_order_nb:
            item["Order_Nb"] = new_order_nb
            save_inventory_to_db(item)

    # 发射信号通知界面刷新
    data_manager.data_changed.emit()
    data_manager.inventory_changed.emit()


def can_delete_purchase_order(order_nb):
    """
    检查是否允许删除采购订单：
    如果有销售订单（包括扣减详情中引用）使用该订单号，则返回 False。
    """
    for s_order in sales_orders:
        if s_order.get("Order_Nb", "") == order_nb:
            return False
        for deduction in s_order.get("Deduction_Details", []):
            if deduction.get("Order_Nb") == order_nb:
                return False
    return True


def delete_purchase_order_with_check(order_nb):
    """
    删除采购订单前先检查关联的销售订单：
      - 若存在销售订单引用该订单，则弹出提示并阻止删除。
      - 若不存在关联销售订单，则执行删除，并对库存记录进行级联更新。
    """
    if not can_delete_purchase_order(order_nb):
        QMessageBox.warning(None, "删除错误", f"采购订单 {order_nb} 存在关联的销售订单，无法删除！")
        return

    # 从内存中删除采购订单
    global purchase_orders
    purchase_orders = [order for order in purchase_orders if order.get("Order Nb") != order_nb]
    # 从数据库中删除
    delete_purchase_order_from_db(order_nb)

    # 对库存记录进行级联处理：
    # 如果库存记录仍引用该订单号，将其标记为“已删除订单: 原订单号”
    for item in inventory:
        if item.get("Order_Nb", "") == order_nb:
            item["Order_Nb"] = f"已删除订单: {order_nb}"
            save_inventory_to_db(item)

    data_manager.data_changed.emit()
    data_manager.inventory_changed.emit()
    QMessageBox.information(None, "成功", f"采购订单 {order_nb} 已删除。")